[{"id":"10e799bf47669bd7fff35712248e1c6e","title":"2021年度总结","content":"引言这是我第一次写年度总结在自己的博客上面，用来总结这一年到底干了什么，以及需要改进的是什么。2021年对我来说是一个过渡期，可能是让我更加明确自己方向的一个时期，但是在这方面还是拥有一点疑虑，需要再深思熟虑。\n2021年做了什么？其实大致的忘了自己2021年开始到底做了什么，因为那个时候正是大二上结束的时候，是刚考完四级盼望自己过四级的时候。在寒假快要结束时得知了自己过了四级，很快乐。\n寒假的期间收到了一通电话，说自己的网站需要备案，所以需要去当地警局一趟。由于感觉太远了，就拒绝没去了，之后就找客服把网站的域名备案取消了（现在一想还是github的免费博客好用）。那个时候的是SaripaintGo项目（是一款绘画网站）的末期了，因为当时丰厚的知识去解决一系列问题，导致功能一再再的拖后。在这个项目上我感觉自我只追求前端页面的好看，并没有深刻的了解后端的框架知识（如MVC，Spring），一直用的Go写，挺尴尬的。但是这个小项目给我之后的作业打了一定的底子，我大致了解了一个Web应用服务端运作方式，还是挺有帮助的。\n寒假结束后是大二下学期，这个学期的作业并不是很多，但是感觉自己在这个学期的过程，并没有着手一些可以提升自己的项目，着实感到些许遗憾。所以说着手做一件事情是真的很重要，比如在大二下这学期的数据库的项目中，我就是用了相应的网络编程的知识，所以在这个数据库实验方面达到了较好的效果。\n大二下结束了是暑假，暑假是我觉得最尴尬的一个暑假，我觉得所有问题都来源于自己的判断失误，这个失误我暂且不提，我认为这是我整个学习以来接下的最不好的失误任务（在此打个暗号：机器学习。我至今将无法忘记这件事，真让人感到尴尬），总之就是我当时没有预测到到底能不能得到一定的资源，可惜没有，才导致了整个暑假的打水漂。\n暑假大致主要干了三个事情：背单词，编程，以及unity。对于编程唯一感到可惜的就是没有认真的写letcode的相关题目，失去了这个长时间的机会。对于unity的话，只做了初步了解，并没有过多的深入，感觉还是差一个比较好的教程进行学习。背单词犯了一个比较基本的错误，那就是，应该直接按照单词书上的词汇来背，而不是按照一点都不适合自己的网上的方法进行背单词，这很显然浪费了自己宝贵的时间。\n暑假过后是大三上，从这个时期开始，大学的时光就已经过去一半了，慢慢的，自己也要面临选择的问题了。在这一个学期，单词只背到了25个List（总共30List），这是一个比较遗憾的事情，因为最后的实验报告压力实在巨大，以及外界的影响（说的太好听了，就是不专心），导致单词只背了这么多，很可惜。在这个学期学的课程里面，并没有感到很多有很大实质性的提高，唯一一个感觉就是自己被实验项目压垮的感觉（但是还是自己扛过来了），但是我觉得这个原因还是跟那个原因影响有关，在此我暂且不提，是在是太令人遗憾，以及感到深深的自责。\n对了，还有六级的事情呢，感觉这次六级还是过不了，啊啊啊啊！！\n剩下的就是现在写这个感想的的时间了，现在距离2021结束还剩下一个小时。\n反省对于这一年的种种事情，我认为自己需要认识到几个问题。\n\n第一，我得思考自己到底想要做什么，以及到底想为了什么，而不是一时的头脑冲动，却啥也没有得到。\n第二、在完成一件事情的过程中，得用实质性的东西约束自己认真完成，而不是三天打鱼两天晒网，而不是走马观花，没有一丝认真的态度。总之就是要保证正确的态度去完成任务（说正常点就是不要玩手机，以及看其他无关的东西）。\n第三、正确的去判断某一个东西的好坏，要结合自己的情况，以及当时所处环境的情况，而不是一时头脑发热就答应某些根本不可能完成的问题。\n\n2022想要做的事情\n着手开始考研复习的相关流程，之后会在寒假期间制定相应计划。\n在大三下学期明确自己的方向，以及努力的去寻找并判断好的机会。\n学会独自一个人去教室复习，而不是待在教室，多思考去如何解决。\n完成考研\n通过unity完成一款同人音乐游戏（不求精致，只求学到了什么）。\n在寒假期间练习leetcode的题目，为四月份的蓝桥杯做打算。\n\n总结2021结束了，2022的到来，需要去掉2021的坏习惯，将好的习惯留到下一年继续发扬。不要忘记所有帮助自己的人，要留存着敬畏之心。友善地对待生活中的每一个人，不要去思考与自己无关的事情。\n时刻反省自身，时刻认识到自身的错误，进一步的提高自己。\n抓住机会！\n警惕陷阱！\n","slug":"2021年度总结","date":"2021-12-31T12:34:06.000Z","categories_index":"年度总结","tags_index":"总结","author_index":"懒懒瑭岚"},{"id":"9e81543b01b9fb4d973d1efdec16b262","title":"操作系统期末复习","content":"题型我不知道\nChp1 绪论暂且不整理\nChp2 操作系统的组织结构操作系统虚拟机什么是操作系统虚拟机？\n在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。\n处理机的状态设置处理机状态的目的？\n为操作系统建立一个保护环境，采用的办法是区分处理机的工作状态。在系统中存在两类程序，一类是管理程序，另一类是用户程序。\n什么是处理机的状态？\n中央处理机的工作状态，当前它正在执行哪类程序，决定处理机的态。\n管态与用户态\n\n管态：又称系统态，是操作系统管理程序执行时机器所处的状态。在此状态下允许中央处理机使用全部系统资源和全部指令（包括一组特权指令），允许访问整个存储区。\n用户态：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。\n\n\n\n\n管态\n用户态\n\n\n\n操作系统的程序执行\n用户程序执行\n\n\n使用全部指令（包括一组特权指令）\n禁止使用特权指令\n\n\n使用全部系统资源（包括整个存储区域）\n只允许用户程序访问自己的存储区域\n\n\n特权指令\n中断技术中断概念\n所谓中断是指某个事件发生时，系统终止现行程序的运行、引出处理该事件程序进行处理，处理完毕后返回断点，继续执行。\n中断类型\n如下列举一个类型，访管中断：对操作系统提出某种需求（如请求I/O传输、建立进程等）时所发出的中断称为访管中断。\n向量中断什么是向量中断？\n当中断发生时，由中断源引导处理机进入终端服务程序的中断过程称为向量中断。在向量中断中，对于每一个中断类型都设置一个中断向量。\n中断向量\n中断向量就是存储该类型中断的终端服务例行程序的入口地址和处理机状态字的存储单元。系统中的所有中断向量放在一起，形成中断向量表。\n向量中断处理过程\n当发生某一中断事件时，根据该类中断的中断向量直接进入处理该事件的中断处理程序。\nChp3 用户界面系统功能调用什么是系统功能调用？\n白话解释：操作系统设计者编制了一些可以完成用户某些功能的例行子程序（操作系统为用户程序提供服务），这些子程序作为操作系统程序模块的一部分。用户的程序是处于用户态的，用户想要调用则需要采用一种特殊的调用方式–访管方式来实现。使用访管指令进入访管中断。\n系统功能调用的实现\n\n用户程序中：svc n\n访管中断处理程序，保存现场\n例行子程序入口地址表\n例行子程序\n执行完毕后恢复现场\n\nChp4 并发处理顺序执行的特点\n\n\n\n特点名\nxxx\n\n\n\n顺序性\n\n\n\n封闭性\n\n\n\n可再现性\n\n\n\n什么是并发执行\n若干个程序段同时在系统中运行，这些程序段在执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。\ncobegin;\n\tfun1(),fun2();\ncoend;\n\n并发执行的特点\n\n失去程序的封闭性和再现性\n程序与计算不再一一对应（计算是指在处理机上的执行过程，或处理机按照程序的规定执行操作的过程，是动态的概念）\n程序并发执行的相互制约\n\n进程概念进程的定义\n\n进程是程序的执行\n并行程序称为进程\n进程是可以和别的计算并发的计算\n进程是一个数据结构及在其上进行操作的程序\n进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动\n\n进程的状态\n\n\n\n状态\ninfo\n\n\n\n就绪状态\n当进程获得了除CPU之外的所有资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行\n\n\n运行状态\n得到了中央处理机的控制权，它的程序正在运行\n\n\n等待状态\n若一进程正在等待某一事件发生，而暂时停止执行，这时，即使给它CPU控制权，它也无法执行\n\n\n进程的描述—进程控制块\n\npcb—process control block\n系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体\n\n","slug":"操作系统期末复习","date":"2021-12-31T06:26:35.000Z","categories_index":"学习","tags_index":"学习","author_index":"懒懒瑭岚"},{"id":"85bcb60ef3df802e81a5da2276802e9f","title":"Unity3d关键词汇总","content":"根据类型获取某个对象\n&#x2F;&#x2F;这里我们找的是Canvas这个对象，该函数只找到一个\nCanvas canvas &#x3D; FindObjectOfType&lt;Canvas&gt;();\n\n获取预制体\n&#x2F;&#x2F;获取预制体\n&#x2F;&#x2F;Resources代表必然有一个存在于Assert下的Resources文件夹\n&#x2F;&#x2F;预制体为相对路径\n&#x2F;&#x2F;获取预制体之后，需要注意类型转化的问题\nGameObject mainPanelPrefab &#x3D; (GameObject)Resources.Load(&quot;UIPrefab&#x2F;MainPanel&quot;);\n\n初始化预制体\nGameObject mainPanel&#x3D;Instantiate(mainPanelPrefab);\n\n设置物体的父节点\nmainPanel.transform.SetParent(canvas.transform);\n\n按钮的点击与匿名回调\nButton button &#x3D; GetComponentInChildren&lt;Button&gt;();\nbutton.onClick.AddListener(delegate()&#123;\n    Debug.Log(&quot;这个按钮被点击了&quot;);\n&#125;);\n\n多个的点击与匿名回调\nButton[] btns &#x3D; GetComponentsInChildren&lt;Button&gt;();\nforeach (Button btn in btns)\n&#123;\n  switch (btn.name)\n  &#123;\n    case &quot;GotoAnotherPanelBtn&quot;:\n      btn.onClick.AddListener(delegate ()\n      &#123;\n        Debug.Log(&quot;切换控制面板&quot;);\n      &#125;);\n      break;\n    case &quot;ExitBtn&quot;:\n      btn.onClick.AddListener(delegate ()\n      &#123;\n        Debug.Log(&quot;退出该面板&quot;);\n      &#125;);\n      break;\n  &#125;\n&#125;\n\nUI的隐藏\n&#x2F;&#x2F;将它Destroy\nDestroy(this.gameObject);\n\n&#x2F;&#x2F;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Unity3d关键词汇总","date":"2021-12-28T04:01:19.000Z","categories_index":"Unity3d","tags_index":"Unity3d,学习","author_index":"懒懒瑭岚"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"题型\n辨析题(对的直接打√，错的打×并改正过来，每小题 2 分，共 20 分)\n简答题(每小题 6 分，共 30 分)\n程序填空题(每空 3 分，共 30 分)\n编程题(每小题 10 分，共 20 分)\n\n复习提纲J2ES部分java 开发环境的下载、安装及配置java的下载\n\n建议下载1.8版本，可以选择压缩包或者安装包下载。使用安装包即可安装。\n\njava环境变量的配置\n# 在系统变量上配置\nJAVA_HOME: \t # 电脑上安装JDK的绝对路径（意思就是这个目录下面包含bin）\nCLASSPATH:   .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n# 在环境变量中配置path\n%JAVA_HOME%\\bin\n%JAVA_HOME%\\jre\\bin\n\n# 编译与运行\njava 运行\njavac 编译\n\njava语言的特性\n\n安全性、可移植性及与平台无关等特性\n\njava虚拟机\n\n在上面运行的是字节码class文件，屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”\n\n垃圾回收\n\n垃圾收集在Java程序运行过程中自动进行，程序员无法精确控制和干预\n\n基本数据类型转换\n容量小的类型自动转换为容量大的数据类型\n数据类型按容量大小排序为byte,short, char-&gt;int-&gt;long-&gt;float-&gt;double\nbyte,short,char之间不会互相转换，他们三者在计算时首先回转换为int类型\n容量大的数据类型转换为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出;使用时要格外注意。\n有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那—种数据类型，然后再进行计算。\n实数常量（如:1.2）默认为double。\n整数常量（如:123）默认为int 。\n\n面向对象编程（有概率为考小题）封装与多态\n\n封装成类\n什么是多态？ 多态是同一个行为具有多个不同表现形式或形态的能力。多态的体现形式：继承、父类引用指向子类、重写。\n\n继承、聚集、实现\n\n继承：extends\n聚集：就是成员变量中使用了其他的类\n\n构造方法\n命名规则\n\n类名的首字母大写\n变量名和方法名的首字母小写\n运用驼峰标识\n\nthis与super\n\nthis为当前对象，super为父类\n\nstatic\n\n在类中，用static声明的成员变量为静态成员变量，它为该类的公用变量，在第一次使用时被初始化，对于该类的所以对象来说，static成员变量只有一份。\n用static声明的方法为静态方法，在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员。\n静态方法不再是针对于某个对象调用，所以不能访问非静态成员\n可以通过对象引用或类名(不需要实例化）访问静态成员。\n\npublic static int a;\npublic static void fun();\n\npackage与import\n\n是为了解决类命名冲突的问题，那么在不同包下，类的名字可以相同。\npackage：打包\nimport：引用\n\npackage com.lltl.service;\n\nimport com.lltl.dao;\n\n关键字this与super\n\nthis是指对象本身\nsuper指向父类\n\n重写\n\n对基类的方法进行重写，或者是实现接口\n关键词@override\n\n权限控制和类的继承\nObject类\n\n里面含有toString方法与equals方法\n\n理解并掌握动态绑定和多态\n\n动态绑定：当调用某个对象的方法时，会从它的继承链向上寻找，若是找到了，则使用。否则继续向父类寻找。\n这类题目我猜测，就是普通类的继承，然后在通过多态的方式进行绑定，如下给个程序例子\n\nclass Shape &#123;\n    void draw() &#123;&#125;\n&#125;\n \nclass Circle extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Circle.draw()\");\n    &#125;\n&#125;\n \nclass Square extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Square.draw()\");\n    &#125;\n&#125;\n \nclass Triangle extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Triangle.draw()\");\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n      show(new Cat());  // 以 Cat 对象调用 show 方法\n      show(new Dog());  // 以 Dog 对象调用 show 方法\n                \n      Animal a = new Cat();  // 向上转型  \n      a.eat();               // 调用的是 Cat 的 eat\n      Cat c = (Cat)a;        // 向下转型  \n      c.work();        // 调用的是 Cat 的 work\n  &#125;  \n            \n    public static void show(Animal a)  &#123;\n      a.eat();  \n        // 类型判断\n        if (a instanceof Cat)  &#123;  // 猫做的事情 \n            Cat c = (Cat)a;  \n            c.work();  \n        &#125; else if (a instanceof Dog) &#123; // 狗做的事情 \n            Dog c = (Dog)a;  \n            c.work();  \n        &#125;  \n    &#125;  \n&#125;\n \nabstract class Animal &#123;  \n    abstract void eat();  \n&#125;  \n  \nclass Cat extends Animal &#123;  \n    public void eat() &#123;  \n        System.out.println(\"吃鱼\");  \n    &#125;  \n    public void work() &#123;  \n        System.out.println(\"抓老鼠\");  \n    &#125;  \n&#125;  \n  \nclass Dog extends Animal &#123;  \n    public void eat() &#123;  \n        System.out.println(\"吃骨头\");  \n    &#125;  \n    public void work() &#123;  \n        System.out.println(\"看家\");  \n    &#125;  \n&#125;\n\nfinal 关键字\n\n在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）\n当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。\n对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。\n方法不能被重写\n\n数组数组的声明\ndataType[] arrayRefVar;   // 首选的方法\n\ndataType[] arrayRefVar = new dataType[arraySize];\n\n//静态初始化\ndataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;\n\n二维数组\n\n注意二维数组不等长特性\n\nint a[][] = new int[3][];\na[0] = new int[2];\na[1] = new int[3];\na[2] = new int[4];\n\n常用类String与StringBuffer的特点以及区别\n\n\n\n\nString\nStringBuffer\n\n\n\n区别\n是对象不是原始类型.\n是一个可变对象,当对他进行修改的时候不会像String那样重新建立对象\n\n\n\n为不可变对象,一旦被创建,就不能修改它的值.\n它只能通过构造函数来建立,\n\n\n\n对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.\nStringBuffer sb = new StringBuffer();\n\n\n\nString 是final类,即不能被继承.\n对象被建立以后,在内存中就会分配内存空间,并初始保存一个null.通过它的append方法向其赋值.sb.append(“hello”);\n\n\n优点\n\n字符串连接操作中StringBuffer的效率要明显比String高\n\n\n\n\nString对象是不可变对象,每次操作Sting 都会重新建立新的对象来保存新的值\n\n\n\n\nStringBuffer对象实例化后，只对这一个对象操作\n\n\nStringBuffer\n\n\n\n方法\n使用\n\n\n\npublic StringBuffer append(String s)\n将指定的字符串追加到此字符序列\n\n\npublic insert(int offset, int i)\n将 int 参数的字符串表示形式插入此序列中\n\n\npublic delete(int start, int end)\n移除此序列的子字符串中的字符\n\n\npublic StringBuffer reverse()\n将此字符序列用其反转形式取代\n\n\n容器类Collection\n\n可以放入不同类型的对象（由于是用Object承接的）\n\nIterator\n\n所有实现了collection接口的容器类都有一个iterator方法用以返回一个实现了Iterator接口的对象。\nIterator对象称作迭代器，用以方便的实现对容器内元素的遍历操作。\nIterator接口定义了如下方法:\n\nboolean hasNext()    //判断游标是否有元素\nObject next();\t\t//返回游标右边的值并且将游标下移一个位置\nvoid remove();\t\t//删除游标左边的元素，当删除了就不能再删除了，除非再次next\n\nSet\n\nSet接口是Collection的子接口，Set接口没有提供额外的方法，但实现Set接口的容器类中的元素是没有有顺序的,而且不可以重复。\nSet容器可以与数学中“集合”的概念相对应。\nJ2SDK API中所提供的 Set容器类有HashSet,TreeSet等。\n\nList\n\nList接口是Collection的子接口，实现List接口的容器类中的元素是有顺序的,而且可以重复。\nList容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\nJ2SDK所提供的List容器类有ArrayList，LinkedList等。\n\nObject get(int index);\nObject set(int index, Object element);\nvoid add(int index, object element);\nObject remove(int index);\nint indexof(Object o);\nint lastIndexof(Object o);\n\nMap\n\n实现Map接口的类用来存储键一值对。\nMap接口的实现类有HashMap和TreeMap等。\nMap类中存储的键一值对通过键来标识，所以键值不能重复。\n\nObject put(Object key, Object value);\nObject get(Object key);\nObject remove(Object key);\nboolean containsKey(Object key);\nboolean containsvalue(Object value);\nint size();\nboolean isEmpty();\nvoid putA11(Map t);\nvoid clear();\n\n迭代器在List、Set、Map的遍历\n//通过迭代器遍历List\nfor(Iterator iter2 = list.iterator();iter2.hasNext();)&#123;\n    String str = (String) iter2.next();\n    System.out.println(str);\n    iter2.remove();\n    iter2.remove();\n&#125;\n\n//通过迭代器遍历Set\nfor(Iterator iter = set.iterator();iter.hasNext();)&#123;\n    String str = (String) iter.next();\n    System.out.println(str);\n&#125;\n\n//遍历Map的第一种方式\nSet keys = map.keySet();\nfor(Iterator iter = keys.iterator();iter.hasNext();)&#123;\n    String keyStr = (String) iter.next();\n    System.out.println(keyStr+\"---\"+map.get(keyStr)); \n&#125;\n\n//遍历Map的第二种方式\nSet&lt;Entry> set2 = map.entrySet();\nfor(Iterator iter = set2.iterator();iter.hasNext();)&#123;\n    Entry e = (Entry) iter.next();\n    System.out.println(e.getKey()+\"---\"+e.getValue());\n&#125;\n\n增强for循环\nint[] numArray = &#123; 1, 2, 3, 4, 5, 6 &#125;;\nfor (int i : numArray) &#123;\n    System.out.print(i);\n&#125;\n\nList、Set、Map 各自的特点及区别\n\n\n\n比较\nList\nSet\nMap\n\n\n\n继承接口\nCollection\nCollection\n\n\n\n常见实现类\nAbstractList(其常用子类有ArrayList、LinkedList、Vector)\nAbstractSet(其常用子类有HashSet、LinkedHashSet、TreeSet)\nHashMap、HashTable\n\n\n常见方法\nadd( )、remove( )、clear( )、get( )、contains( )、size( )\nadd( )、remove( )、clear( )、contains( )、size( )\nput( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )\n\n\n元素\n可重复\n不可重复(用equals()判断)\n不可重复\n\n\n顺序\n有序\n无序(实际上由HashCode决定)\n\n\n\n线程安全\nVector线程安全\n\nHashtable线程安全\n\n\nJ2EE部分TomcatTomcat操作\n\n启动:到tomcat主目录下bin/startup.bat\n停止:到 tomcat主目录下bin/shutdown.bat\n启动:在命令行输入startup或catalina start\n停止:在命令行输入shutdown或catalina stop\n输入http://localhost:8080/，显示如下界面代表安装成功（就是tomcat管理界面）\n\nTomcat的目录层次结构\n\n\n\n目录\n用处\n\n\n\nbin\n存放启动和关闭Tomcat的脚本文件\n\n\nconf\n存放Tomcat服务器的各种配置文件\n\n\nlib\n存放Tomcat服务器的支撑jar包\n\n\nlogs\n存放Tomcat的日志文件\n\n\ntemp\n存放Tomcat运行时产生的临时文件\n\n\nwebapps\nweb应用所在目录，即供外界访问的web资源的存放目录\n\n\nwork\nTomcat的工作目录\n\n\nconf目录下的3个xml文件\n\n\n\nxml\n功能\n\n\n\nsever.xml\n该文件用于配置和server相关的信息,比如tomcat启动端口号,配置Host，配置Context 即web应用\n\n\nweb.xml\n该文件用于配置与web应用(web应用就相当于是一个web站点)相关的信息\n\n\ntomcat-users.xml\n该文件用于配置tomcat的用户角色和密码。\n\n\nWEBB/S结构\n\nBrowser—-WEB—-Database\n优点：开发成本低、管理维护简单、产品升级便利、对用户培训费用低、用户使用方便、出现故障几率小\n缺点：安全性不足、显示效果受浏览器限制\n\n\n\nC/S结构\n\nClient—-Server\n\nServletServlet基本概念\n\nServlet是服务器端的小应用程序\n用来完成B/S架构下，客户端请求的响应处理\n平台独立，性能优良，能以线程方式运行\nServlet API为Servlet提供了统一的编程接口\nServlet一般在容器中运行\n常见的Servlet容器有:TomcatJetty\n\nServlet的分类\n\n普通\n\n一般用作控制器（Controller）\n\n\n过滤\n\n监听\n\n在线计数器\n在线人员列表\n\n\n\nServlet的工作流程（图解）\n\n\nServlet工作原理\n\n工作原理：反射+回调，容器反射出Servlet对象后回调其方法。\n\nServlet生命周期\n\n加载，ClassLoader\n实例化，new\n初始化，init(ServletConfig)\n处理请求，Service-&gt;\\doPost()\\doGet()\n退出服务，destroy()\n\n开发步骤代码赏析\n\nxml部分\n\n&lt;servlet>\n    &lt;!-- 1 -->\n    &lt;servlet-name>GetUserTable&lt;/servlet-name>\n    &lt;!-- 2 -->\n    &lt;servlet-class>com.zsl.controller.GetUserTable&lt;/servlet-class>\n&lt;/servlet>\n\n&lt;servlet-mapping>\n    &lt;!-- 3 -->\n    &lt;servlet-name>GetUserTable&lt;/servlet-name>\n    &lt;!-- 4 -->\n    &lt;url-pattern>/getUserTable&lt;/url-pattern>\n&lt;/servlet-mapping>\n\n&lt;!-- 服务器解析顺序：4->3->1->2 -->\n\n\nservlet部分\n\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    request.setCharacterEncoding(\"utf-8\");\n    response.setContentType(\"text/html;charset=utf-8\");\n    //获取参数\n    String rows = request.getParameter(\"rows\") != null ? request.getParameter(\"rows\") : \"0\";\n    String page = request.getParameter(\"page\") != null ? request.getParameter(\"page\") : \"0\";\n    String sortOrder = request.getParameter(\"sortOrder\") == null ? request.getParameter(\"sortOrder\") : \"asc\";\n    System.out.println(rows + \" \" + page);\n    //查询数据\n    Map&lt;String, String> data = null;\n    try &#123;\n        data = usersService.getUserTableJson(new String[]&#123;rows, page, sortOrder&#125;);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    //返回数据\n    PrintWriter out = response.getWriter();\n    String s = \"&#123;\" +\n        \"\\\"total\\\":\" + \"\\\"\" + data.get(\"total\") + \"\\\"\" + \",\" +\n        \"\\\"rows\\\":\" + data.get(\"rows\") +\n        \"&#125;\";\n    out.write(s);\n&#125;\n\n过滤器运行过程\n\n在一个Web应用中包含多个Filter，组合起来称之为Filter链\nFilter的调用顺序是按照web.xml的注册顺序进行调用的\ndoFilter()\n\n样例代码\n&lt;!-- 过滤器 -->\n&lt;filter>\n    &lt;filter-name>CharacterEncodingFilter&lt;/filter-name>\n    &lt;filter-class>com.zsl.filter.MyEcdFilter&lt;/filter-class>\n    &lt;init-param>\n        &lt;param-name>encode&lt;/param-name>\n        &lt;param-value>utf-8&lt;/param-value>\n    &lt;/init-param>\n&lt;/filter>\n&lt;filter-mapping>\n    &lt;filter-name>CharacterEncodingFilter&lt;/filter-name>\n    &lt;url-pattern>/*&lt;/url-pattern>\n    &lt;!-- 过滤器拦截规则:request过滤器，include过滤器，forward过滤器，error过滤器 -->\n    &lt;dispatcher>REQUEST&lt;/dispatcher>\n    &lt;dispatcher>FORWARD&lt;/dispatcher>\n&lt;/filter-mapping>\n\n监听器三个域对象的监听\n\nServletContext----application\nHttpSession----Sessiom\nServletRequest----request\n\n监听器+Session监听器\npackage com.zsl.listener;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\nimport javax.servlet.http.HttpSessionAttributeListener;\nimport javax.servlet.http.HttpSessionBindingEvent;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@WebListener\npublic class OnlineCountingListener implements ServletContextListener, HttpSessionAttributeListener, HttpSessionListener &#123;\n    ServletContext application = null;\n\n    //监听初始化的时候\n    @Override\n    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;\n        //用一个列表保存用户的信息\n        List&lt;String> list = new ArrayList&lt;String>();\n        //取得Context对象\n        application = servletContextEvent.getServletContext();\n        //将用户列表放入\n        application.setAttribute(\"allUser\", list);\n    &#125;\n\n    //当监听关闭时（服务器被关闭\n    @Override\n    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;\n        System.out.println(\"服务器关闭\");\n    &#125;\n\n    //当Session中添加的新的属性时（也就是有用户登录了\n    @Override\n    public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n        List&lt;String> list = (List&lt;String>) application.getAttribute(\"allUser\");\n        //假设：用户登陆成功之后，只将户名设置到session中\n        if (((String) httpSessionBindingEvent.getName()).equals(\"user\")) &#123;\n            System.out.println(\"添加：\" + (String) httpSessionBindingEvent.getSession().getAttribute(\"user\"));\n            String userName = (String) httpSessionBindingEvent.getSession().getAttribute(\"user\");\n            //取得用户名\n            if (list.indexOf(userName) == -1) &#123;\n                //表示此用户之前没有登陆\n                list.add(userName);\n                application.setAttribute(\"allUser\", list);\n            &#125;\n        &#125;\n    &#125;\n\n    //当Session中某个用户退出登录了\n    @Override\n    public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n        //只对user敏感\n        if (((String) httpSessionBindingEvent.getName()).equals(\"user\")) &#123;\n            List&lt;String> list = (List&lt;String>) application.getAttribute(\"allUser\");\n            System.out.println(\"移出：\" + (String) httpSessionBindingEvent.getValue());\n            list.remove((String) httpSessionBindingEvent.getValue());\n            application.setAttribute(\"allUser\", list);\n        &#125;\n    &#125;\n\n    @Override\n    public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n\n    &#125;\n\n    @Override\n    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;\n\n    &#125;\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;\n\n    &#125;\n&#125;\n\nxml配置\n&lt;listener> \n    &lt;listener-class>com.kiqi.listener.MyListener&lt;/listener-class>\n&lt;/listener>\n\nServletContext\n\n一个web应用对应一个ServletContext，作用于全局\n\nvoid setAttribute(String name,Object value);\nObject getAttribute(String name);\nremoveAttribute(String name);\n\n\n\nCookie&amp;Session二者的区别\n\nCookie保存在客户端\nSession保存在服务端\n\n如何使用Session\n//获取Session\nHttpSession session = request.getSession();\n\n//设置Session\nsession.setAttribute(\"user\", name);\n\n//获取Session里面字段的值\nsession.getAttribute(\"user\");\n\n在服务端操作Cookie\n//获取Cookie，返回的是一个数组\nCookie[] cookies = request.getCookies();\n\n//添加Cookie\nCookie cookie = new Cookie(\"cookieName\", \"cookieValue\");\nresponse.addCookie(cookie);\n\n\n\nJDBC Statement与PreparedStatement的区别\n\nPreperedStatement是Statement的子接口，它的实例对象可以通过调用Connection.prepareStatement()方法获得，相对于Statement对象而言\nPreperedStatement可以避免SQL注入的问题。\nStatement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。PreparedStatement可对SQL进行预编译，从而提高数据库的执行效率。\n并且PreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。\n\n防SQL注入\npublic static ResultSet executeQuery(String sql, Object[] params) &#123;\n    ResultSet rs = null;\n    try &#123;\n        conn = C3P0Util.getConnection();\n        ps = conn.prepareStatement(sql);\n        //对？赋值\n        if (params != null) &#123;\n            for (int i = 0; i &lt; params.length; i++) &#123;\n                ps.setObject(i + 1, params[i]);\n            &#125;\n        &#125;\n        rs = ps.executeQuery();\n    &#125; catch (SQLException e) &#123;\n        e.printStackTrace();\n    &#125;\n    return rs;\n&#125;\n\n前端部分传递表单&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n    Username: &lt;input type=\"text\" name=\"username\">\n    Password: &lt;input type=\"password\" name=\"password\">\n    File: &lt;input type=\"file\" name=\"file\">\n    &lt;input type=\"submit\">\n&lt;/form>\n\n理论问题预测(截取至书本)简述C/S与B/S的区别\n\n硬件环境的不同C/S：一般建立在专用的网络上，小范围里的网络环境、局域网之间再通过专门的服务器提供连接和数据交换服务。B/S：建立在广域网至上的，不必是专门的网络硬件环境，有比C/S更强的适应范围，一般只要有操作系统与浏览器就行。\n对安全要求不同C/S：一般面向相对固定的用户群，对信息安全的控制能力很强，高度机密的信息系统一般采用C/S结构。B/S：建立在广域网之上，对安全的控制能力相对较弱，可能面向不可知的用户。\n对程序架构不同C/S：程序可以更加注重流程，可以对权限多层次校验，对系统运行速度可以较少考虑。B/S：对安全以及访问速度的多重考虑，建立在需要更加优化的基础之上\n软件重用不同C/S：程序可以不可避免地整体新考虑，构建的重用性不如在B/S要求下的构建的重用性好。B/S：对多重结构，要求构建相对独立的功能。\n系统维护不同C/S：程序由于整体性，必须整体考察、处理出现的问题以及系统升级B/S：构件组成，方便个别构件的更换，实现系统的无缝更新。\n处理问题不同C/S：程序可以处理用户面固定，并且在相同区域，安全要求该，与操作系统相关。B/S：建立在广域网之上，面向不同的用户群，地域分散，这是C/S不能做到的\n用户接口不同C/S：多事建立在Windows平台上，表现方法有限，对称需要普遍要求较高。B/S：建立在浏览器上，与用户交流时有更加丰富和生动的表现方式；并且大部分难度降低，降低了开发成本。\n信息流不同C/S：程序一般是典型的重要集权的机械式处理，交互性相对较低。B/S：信息流向可变化，B-B、B-C、B-G等信息，流向的变化，更像是交易中心。\n\n简述一下Servlet作用原理以及生命周期\n\nServlet的工作原理主要是反射+回调。Servlet的执行时其容器如Tomcat通过web.xml的配置反射出Servlet对象后回调其Service方法。目前所有的MVC框架的Controller基本都是这种模式。\nServlet的声明周期主要包括三部分：\n初始化，Web容器加载Servlet，调用init()方法\n处理请求，当请求到达时，运行其Service()方法，Service会自动派遣运行与请求相对应的doPost与doGet\n销毁，服务结束Web容器会调用Servlet的方法销毁Servlet\n\n\n\n简述Filter生命周期的认识\n\n服务器启动的时候，Web服务器会创建Filter的实例对象，并调用其init方法，完成对象的初始化功能。FIlter对象只会创建一次，init方法也只会执行一次。Filter的创建和销毁有Web服务器控制。\n拦截到请求时，执行doFilter方法。可执行多次。\n服务器关闭时，Web服务器销毁Filter的实例对象。\n\n简述Servlet监听器的作用\n\nServlet监听器对特定的事件进行监听，当产生这些事件的时候，会执行监听器的代码。可以是对应的加载、卸载，对Session的初始化、销毁，对Session的初始化、销毁，对Session中值变化等事件进行监听。看，  这\n\n简述MVC的完整流程\n\nMVC（模型、视图、控制器）架构的控制流程为：所有的终端用户的请求被发送到控制器，控制器依赖请求去选择加载哪个模型，并把模型附加到对应的视图，附加了模型数据的最终视图作为响应发送给终端用户。\n\n","slug":"java期末复习","date":"2021-12-27T02:15:41.000Z","categories_index":"学习","tags_index":"学习,java","author_index":"懒懒瑭岚"},{"id":"718afa12fb66304ba8ec0b546fe6aafc","title":"随思所想（二）","content":"考完六级今天考完六级了，总而言之，来年再战（悲），自己的缺陷还很明显，需下次努力\n需完成的目标\n词汇量\n精读，快速阅读文章\n翻译专有词汇\n限时内考核\n\n","slug":"随思所想（二）","date":"2021-12-18T11:41:26.000Z","categories_index":"日记","tags_index":"随思所想","author_index":"懒懒瑭岚"},{"id":"fab7b4dd4790a8b9e5df3ddde73f6c0d","title":"随思所想（一）","content":"作业很多最近的作业很多，包括很多实验项目，都是要在固定时间内完成的。Java一个网页项目，ASP一个网页项目，数据库一个网页项目\nASP的项目真的很累，老师不让用Java写，只让用.NET的框架写。由于当时不知道可以使用.NET core MVC框架来写项目，导致就用了个普通的.ashx一般处理程序来当做后端的API接口。写的真是很累，组内的话只有两个人来写（虽然是五个人的组，但是有些人的能力还是有一点不足，所以就没让他们写），但是另外一个写的朋友，哎~，可能是没时间吧，剩余的接口都没写了，哎，心真的很累。\nJava是一个书城项目，相比于上面的ASP写的方便许多。在组内的管理上（还是上面五个人）比较有进步（虽然大部分还是自己的，就看他们没时间吧）。使用的是纯Servlet+前端的做法，很傻。但是现阶段不想尝试spring-boot了，心累。vue-element还可以接受。\n数据库的的网页项目我加的是另一个组。挺感谢那个组的组长，一个人就把项目写完了（不怎么难），感谢感谢。节省了我大部分时间，我能够有更多的时间完成ASP与java了（哭）。\n其实之前也想跟一些比较厉害的人组队。（因为本人大致会前端后端的相关知识，所以可以很好的听从组长的指挥）但是由于想组队的人都组完了，于是就一个人做全栈了（虽然做的项目也不是什么大项目，也感觉逻辑很傻，需要学习的还很多）\n之后感觉逐渐陷入怠卷了，尽管自己写完了项目，但是还有很多事情就要做（比如明天要考六级），但是自己真的打不起动力来复习（虽然一直在背单词，但是感觉效率很低）于是才有了这篇博客。其实我很希望我自己在完成一件事的时候，能够不看手机。\n哎~我想分析下原因，每当自己想要思考的时候，不自觉的就打开了B站，然后看些没有意义的视频，其实是感到自责的，突然反应过来后，感觉整个人好像落空一般。\n其实还有一点是喜欢自己一个人待在寝室，感觉去教室复习太远了（哎感觉一个人去真的很怕），但是在寝室也可能存在外部的干扰，这一点自己也注意到，正在努力的改正过来。\n反省还是需要用一件事情制约自己。之所以在写博客，正是因为我想放松下自己的心态（明天考六级），但是很显然不是个有效办法，但是这是能找到的最好的办法了。\n感觉自己写博客的时候比较专心吧，能够反省到自己的错误，愿改正。\n希望改正不是一腔热血，这是一个长久的过程，希望自己记住。\n六级加油冲冲冲！！！！！\n","slug":"随思所想（一）","date":"2021-12-17T13:16:24.000Z","categories_index":"日记","tags_index":"随思所想","author_index":"懒懒瑭岚"},{"id":"c2654dc17a414a2cd81c7456edf987f6","title":"欢迎来到懒懒瑭岚的博客","content":"这个博客写的是什么?欢迎来到懒懒瑭岚的博客，博客里面会写写个人日记、开发日记以及相关的技术总结小文章，总之是一个监督自己态度的博客，严于律己。\n目标希望能开发一个同人游戏，学习游戏开发的知识\n现状(2021-12-17)\n哎，还要考六级呢，还有一堆实验报告\n","slug":"欢迎来到懒懒瑭岚的博客","date":"2021-12-17T13:12:30.000Z","categories_index":"博客需知","tags_index":"welcome","author_index":"懒懒瑭岚"},{"id":"9ca1427602c27c6cd9d92e1b88f90384","title":"如何使用hexo","content":"如何生成post页面hexo new post [xxx]\n\n如何使用静态图片首先得把**_config.yml**文件中\npost_asset_folder: true\n\n随后，在新建页面的时候，则会出现相同的文件夹，用于存放静态文件\n注意要找到文件的相对路径，比如我的就是\ncover: /post/如何使用hexo/m005.jpg\n\n如何添加标签与目录tags: # 这是标签\n  - hexo \ncategories: # 这是目录\n  - hexo\n\n","slug":"如何使用hexo","date":"2021-12-17T13:04:50.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"懒懒瑭岚"}]