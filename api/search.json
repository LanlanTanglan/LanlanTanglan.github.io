[{"id":"759b614f101e52f4adb9ec12f974fa39","title":"计网期末复习","content":"题型\n计算机网络基础知识（每小题5 分，共40分）\n计算机网络系统分析（共20分  每小题10分）\n计算机网络系统设计（共30分 16+14）\n计算机网络工具使用（共10分）\n\nChp1 概述什么是计算机网络？\n利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。\n互联网的组成边缘部分\n由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信和资源共享。客户-服务器方式：客户和服务器都是指通信中所涉及的两个应用程序。客户-服务器方式所描述的是进程之间服务和被服务的关系。对等连接方式：（简称P2P）两台主机在通信时不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件，他们就可以进行平等的、对等连接通信。\n核心部分\n\n由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的。\n电路交换：这种必须经过“建立连接”到“通话”到“释放连接”三个步骤的交换方式成为电路交换。电路交换的一个重要特点就是在通话的全部时间内，通话的两个用户始终占有端到端的通信资源。\n分组交换：\n报文交换：\n\n计算机网络的性能速率：Mbps\n带宽：最高数据率\n发送时延：发送帧长度/发送速率。\n传播时延：信道长度/电磁波在信道的传输速率。这个传输速率一般会给，不然就是3*10^8 m/s\n处理时延\n排队时延\n总时延=发送时延+传播时延+处理时延+排队时延。\n时延带宽积：传播时延*带宽\n往返时间RTT\n有效数据率：数据长度/发送时间+RTT\n计算机网络体系结构什么是计算机网络体系结构?\n计算机网络的各层及其协议的集合就是网络的体系结构。\n协议三要素\n\n语法，即数据与控制信息和结构或格式\n语义，即需要发出何种控制信息，完成何种动作以及做出何种响应\n同步，即时间实现顺序的详细说明\n\n五层协议\n\n应用层\n运输层：\n网络层：IP分组\n数据链路层：帧\n物理层：比特流\n\nChp2 物理层物理层的特性\n\n机械特性\n电气特性\n功能特性\n过程特性\n\nRS-232：物理层串口协议。\nRJ-45：网线的两头所使用的协议\n奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决成为不可能。\n信噪比：信噪比(dB)=10log_10(S/N)。注意：S/N的单位不是dB\n香农公式：C=Wlog_2(1+S/N)，其中W为信道的带宽，C为信道的极限传输速率。\n物理层下面的传输媒体传输媒体：分两类，导引型传输媒体和非导引型传输媒体。导引型传输媒体中，电磁波被导引沿着固体媒体传播；而非导引型传输媒体就是指自由空间，在非引导型传输媒体中电磁波的传输常成为无线传播。\n导引型传输媒体\n\n双绞线\n同轴电缆（x）\n光缆\n\n非导引型传输媒体\nxxx\n信道复用技术频分复用，时分复用，多分复用\n码分复用\n码分复用（CDMA），各用户使用经过特殊调训的不同码型，因此各用户之间不会造成干扰。记用户码片为S，站点码片为T，故S*S=1，S*T=0。\nChp3 数据链路层循环冗余检测（CRC）\n发送方：发送数据为M，选择某一除数P，将M/P所得余数为R，作为冗余码拼接在M的后面得到M’。（注：M=2^nM，其中n为冗余码长度，比除数小1）\n接收方：M’/P的余数等于0，这说明该帧完全正确。否则，这个帧有差错，但是无法知道确切的错误在哪里。\n对于除数P用生成多项式P(X)定义。根据P(X)=X^3+X^2+1得出除数P=1101。\n点对点PPP协议是目前使用得最广泛的数据链路层协议。在边缘与中心部分均有PPP协议的出现。\nPPP协议的特点\n\n简单\n封装成帧\n透明性\n具有链路管理功能\nPPP协议不支持多点线路，而只支持点对点的链路通信。\n\nPPP协议如何实现透明传输？\n透明传输：传输的数据不会与帧定界控制符混淆（无论从键盘上输入什么字符都快可以放在这样的帧中传输过去，这样的传输就是透明传输）。\n字节填充：保证在数据中不能连续出现6个1，故只需要在连续的5个1后添加一个0即可。接收端只需要连续读取到5个1就删除后面的0。\n以太网协议特点：以太网是使用最广泛的局域网技术。由于其简单、成本低、可扩展性强、与IP网能够很好地结合等特点\n使用广播信道的数据链路层CSMA/CD\n含义：带冲突检测的载波监听多点接入/碰撞检测\n存在的原因：在总线型网络上会产生总线使用的冲突问题。因此在同一时间只能允许一台计算机发送数据。\n冲突的原因：在电缆中传播具有传播时延\n碰撞窗口（争用期）：经过争用期这段时间(2t)还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n截断二进制指数退避算法\n\n本质：该算法用来确定碰撞后重传的实际。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是推迟。\n\n\n规定了基本退避时间为2t\n从离散2指数集合（从0到2^k-1）随机取一个数作为r，重传推后的时间就是r*2t。其中k=MIN[重传次数, 10]。\n当重传达到16次仍不能陈宫是，则丢弃该帧，并向高层报告\n\n\n动态退避：推迟的平均时间随重传次数而增大。\n\n以太网的MAC层\nMAC：硬件地址又成为物理地址或MAC地址。\nIEEE 802.3：描述的是物理层与数据链路层的MAC自层的实现。\n扩展的以太网快速以太网协议\nT：代表双绞线；BASE：代表基带传输\n\n\n\n协议名\n功能\n速率\n\n\n\n10BASE-T\n双绞线以太网\n10Mbps\n\n\n100BASE-T\n局域网（LAN）标准\n100Mbps\n\n\n1000BASE-T\n最长距离是100米（LAN）\n1000Mbps\n\n\n碰撞域：在每一时刻碰撞域中只能有一个站点在发送数据。\n广播域：指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为广播域\n交换机的最大优点：对于传统的10 Mbpsd的共享式以太网，若有10个用户，则每个用户占有的平均带宽只有1 Mbps。若使用以太网交换机来连接这些主机，虽然在每个接口到主机的带宽还是10 Mbps，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体带宽，因此对于拥有10个接口的交换机的容量则为100 Mbps。\n以太网交换机的自学习功能\n\n起初以太网交换机的交换表是空的\n交换机收到帧后，首先查找交换表，当在交换表找不到对应的目的MAC以及端口时，广播此帧，并将该主机的端口以及MAC写入交换表。\n找到则不需要广播，并判断是否需要把当前正在发送的端口写入（是否在交换表里面）。\n\n透明网桥\n\n基本功能：自学习转发帧（转发表、散列表）、逆向学习法、生成树算法（即在任何两个站之间只有一条路径）\n工作过程：透明网桥以混杂方式工作，它接收与之连接的所有LAN传送的每一帧。当一帧到达时，网桥必须决定将其丢弃还是转发。如果要转发，则必须决定发往哪个LAN。这需要通过查询网桥中一张大型散列表里的目的地址而作出决定。该表可列出每个可能的目的地，以及它属于哪一条输出线路（LAN）。在插入网桥之初，所有的散列表均为空。由于网桥不知道任何目的地的位置，因而采用扩散算法（floodingalgorithm）：把每个到来的、目的地不明的帧输出到连在此网桥的所有LAN中（除了发送该帧的LAN）。随着时间的推移，网桥将了解每个目的地的位置。一旦知道了目的地置，发往该处的帧就只放到适当的LAN上，而不再散发。\n\n广播风暴\n\n网桥产生广播风暴\n交换机缓解广播风暴\n路由器解决广播风暴\n\nChp4 网络层网络层提供的两种服务\n虚电路服务\n数据报服务\n\n二者的主要区别：\n\n\n\n区别点\n虚电路服务\n数据报服务\n\n\n\n可靠通信\n由网络保证\n由用户保证\n\n\n地址\n只在初次建立时需要\n每个分组均有源、目的地址\n\n\n分组转发\n按同一路由器\n每个分组独立进行转发\n\n\n网际协议IPIP配套的三个协议：地址解析协议ARP、网际控制报文协议ICMP、网际组管理协议IGMP。\n地址解析协议ARP\n\nARP的作用：将IP地址解析解析成相应的硬件地址（MAC）\nARP的工作流程：\n首先本地都拥有一个ARP高速缓存表，用于存储本局域网的所有的IP与MAC的对应关系。当主机想要向某台主机发送IP数据包时，先查找表中是否有对应的信息。（找到了就发送对应的MAC帧数据）\n未找到。ARP进程在本局域网广播发送ARP请求分组。\n在本局域网上所有的主机的ARP进程都收到该分组。若请求分组的IP与自己的一致，向源主机发送ARP响应分组（包含自己的硬件地址）。不一致的其他主机忽略此分组。\n源主机收到目的主机的相应后，将其写在ARP高速缓存表中。\n\n\nARP对保存在高速缓存中的地址映射都存在一定的生存时间。这样子可以防止设备更换、设备坏掉而数据仍然保存在高速缓存中的情况。\n\nIP数据包的格式\n\n\n\n字段名\n意义\n相关问题\n\n\n\n版本\n指IP协议的版本\n\n\n\n首部长度\n4位。其数值代表由有多少个4字节（默认20字节，即是0101）\n\n\n\n区分服务\n\n\n\n\n总长度\n首部长度+数据（分片后）部分长度\nMTU、分片\n\n\n标识\n用于标识分片后的数据包，便于之后的组装\n\n\n\n标志\n还有分片（MF）、不能分片（DF）\n\n\n\n片位移\n13位。某片在原分组的相对位置（8字节为一偏移单位）\n\n\n\n生存时间\n数据包在网络中的寿命\n\n\n\n首部检验和\n\n\n\n\n源地址\n32位\n\n\n\n目的地址\n32位\n\n\n\n题目–数据报的分片\n\n\n\n\n\n\n\n\n\n一个数据包的总长度为3820字节，其数据部分为3800字节长，需要分片为长度不超过1420字节的数据报片。\n明确：首部长20、数据部分3800\n注意：对于数据来说，每8字节为一组。\n路由器转发IP分组\n\n流程：\n对于路由中最重要的两个信息是（目的地址，下一条地址）\n\n\n\n划分子网与构造超网子网\n\n产生子网的原因：IP地址的空间利用率有时候很低。给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变差。两级IP地址不够灵活。\n子网格式：{网络号，子网号，主机号}\n注意：同一网络下的子网的子网号是肯定不一样的。全0全1子网号不可用？\n\n子网掩码\n\n子网掩码采用点分十进制来表示。如：255.255.128.0\n\n超网\n格式：（网络前缀，主机号）。如128.14.35.7/20\n最长前缀匹配：在路由表中匹配的时候应当选择具有最长网络前缀的路由\n互联网的路由选择协议路由协议的分类\n\n内部网关协议IGP：如RIP、OSPF\n外部网关协议EGP：（主要用于处理不同网络之间使用不同路由协议通信的情况）BGP\n\n内部网关协议RIP\n\n本质：\n是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大的优点就是简单。\nRIP只适用于小型互联网。\n\n\n协议的特点：\n仅和相邻路由器交换信息。\n路由器之间交换的信息是当前本路由器知道的全部信息，即自己现在的路由表。\n按固定时间间隔交换信息（定期交换）\n\n\n基于什么协议：UDP\n属于哪一层：传输层\n存在的问题（缺点）：当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器\n\n题目–距离向量算法\n\n\n\n\n\n\n\n\n\n写出在某一时刻更新后的路由表\nxxx\nOSPF\n\n本质：OSPF–开放最短路径优先\n特征：使用分布式的链路状态协议，而不是像RIP那样的距离向量协议。\n特点：\n向本自治系统中所有的路由器发送信息。采用的方式是洪泛法。\n发送的信息就是与本路由器相邻的所有路由器链路状态，但这只是路由器所知道的部分信息。\n只有链路状态发生变化时，路由器才向所有的路由器用洪泛法发送信息。\n更新过程收敛得块\n\n\n由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库，这个数据库实际上就是全网的拓扑结构图。相比于RIP，RIP协议的每一个路由器虽然知道到所有网络的距离以及下一条路由器，但却不知道全网的拓扑结构。\n基于什么协议：IP\n属于哪一层：网络层\n\n外部网关协议BGP\n\n本质：边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的路由，并非寻找一条最佳路由。\n特点：BGP发言人\n基于什么协议：TCP协议\n属于哪一层：网络层\n\n题目–路由配置\n\n\n\n\n\n\n\n\n\n静态路由配置\nxx\nNAT网络地址转换\n\n意义：为了缓解IPv4不够用的情况。\nNAT路由器至少需要一个全球IP地址，才能够与互联网相连。\n\nChp5 运输层（传输层）TCP的拥塞控制流量控制与拥塞控制的区别：流量控制是局部的，拥塞控制是全局的\n拥塞控制的意义：放置过多的数据注入到网络中，这样可以使网络中的路由器或者链路不致过载。\n流量控制的意义：流量控制往往是指点对点通信量的控制，是个端到端的问题。\ncwnd：拥塞窗口状态变量\nssthresh：慢开始门限，不能让窗口大小不断增加，必然需要一个限制变量。\n步骤：\n\n起初cwnd=1\n慢开始：每经过一个传输轮次，cwnd按照以2为底的指数增加。其中，传输轮次与RTT有关，一次RTT就是发送cwnd报文段的时间。\n拥塞避免：当窗口大小大于门限值时，拥塞窗口开始按照线性增长。当出现超时的情况，cwnd立刻变为1，门限值为之前cwnd的一半，并重新开始慢开始。\n快重传：可以让发送方知道发生了个别报文段的丢失。接收方每次接收到新的报文段时，重复返回丢失报文前的确认信息（3个ACK），通知发送方报文段的丢失，随后发送方将丢失报文发送至接收方。因此，发送方不必因为个别报文段的丢失，造成超时，然后重新开始慢开始。\n快恢复：发送方知道只是个别报文段的丢失，不启动慢开始，而是启用快恢复。将门限值修改为当前cwnd的一半，将拥塞窗口与之相等，开始执行拥塞避免算法。\n\nTCP的运输连接管理建立TCP连接–3次握手\n\n接收方状态LISTEN（收听）\n发送方向接收方发送连接请求报文段。其中首部同步位SYN=1，初始序列seq=x。发送方状态CLOSED-&gt;SYN-SENt（关闭状态进入同步已发送）\n接收方收到发送方的连接请求报文段，如同意连接则向发送方发送确认报文段。其中首部SYN=1.确认位ACK=1，确认号ack=x+1，初始序号seq=y。接收方状态LISTEN-&gt;SYN-RCVD（同步收到）\n发送方接收到了接收方的确认报文段，还需向接收方发送确认报文段。其中首部ACK=1，ack=y+1，seq=x+1。发送方状态SYS-SENT-&gt;ESTABLISHED（已建立连接）\n接收方收到发送方的确认报文段后。接收方状态SYN-RCVD-&gt;ESTABLISHED\nTCP连接建立\n\n释放TCP连接–4次握手\n\n发送方向接收方发送连接释放报文段。其中首部终止控制位FIN=1，seq=u（它等于前面已传送过的数据的最后一个字节加1）。发送方状态ESTABLISHIED-&gt;FIN-WAIT-1（终止等待1）\n接收方收到连接释放报文段后，向发送方发送确认报文段。其中首部ACK=1，ack=u+1，seq=v。接收方状态ESTABLISHIED-&gt;CLOSED-WAIT（关闭等待）\n发送方接收到确认报文段之后。接收方状态FIN-WAIT-1-&gt;FIN-WAIT-1（终止等待2）\n接收方通知高层应用进程，连接释放了，确认没有任何需要发送的数据后，向发送方发送连接释放报文段。其中首部FIN=1，ACK=1，seq=w，ack=u+1。接收方状态CLOSED-WAIT-&gt;LAST-ACK（最后确认）\n发送方接收到连接释放报文段后，向接收方发送确认报文段。其中首部ACK=1，ack=w+1，seq=u+1。发送方状态FIN-WAIT-2-&gt;TIME-WAIT（时间等待）。必须经过时间等待计数器设置的时间2MSL后，进入CLOSED状态。\n接收方收到确认报文段后。接收方状态LAST-ACK-&gt;CLOSED\nTCP连接释放\n\nChp5 应用层DNS域名系统DNS的主要功能：\n","slug":"计网期末复习","date":"2022-01-03T02:04:43.000Z","categories_index":"学习","tags_index":"学习","author_index":"懒懒瑭岚"},{"id":"10e799bf47669bd7fff35712248e1c6e","title":"2021年度总结","content":"引言这是我第一次写年度总结在自己的博客上面，用来总结这一年到底干了什么，以及需要改进的是什么。2021年对我来说是一个过渡期，可能是让我更加明确自己方向的一个时期，但是在这方面还是拥有一点疑虑，需要再深思熟虑。\n2021年做了什么？其实大致的忘了自己2021年开始到底做了什么，因为那个时候正是大二上结束的时候，是刚考完四级盼望自己过四级的时候。在寒假快要结束时得知了自己过了四级，很快乐。\n寒假的期间收到了一通电话，说自己的网站需要备案，所以需要去当地警局一趟。由于感觉太远了，就拒绝没去了，之后就找客服把网站的域名备案取消了（现在一想还是github的免费博客好用）。那个时候的是SaripaintGo项目（是一款绘画网站）的末期了，因为当时丰厚的知识去解决一系列问题，导致功能一再再的拖后。在这个项目上我感觉自我只追求前端页面的好看，并没有深刻的了解后端的框架知识（如MVC，Spring），一直用的Go写，挺尴尬的。但是这个小项目给我之后的作业打了一定的底子，我大致了解了一个Web应用服务端运作方式，还是挺有帮助的。\n寒假结束后是大二下学期，这个学期的作业并不是很多，但是感觉自己在这个学期的过程，并没有着手一些可以提升自己的项目，着实感到些许遗憾。所以说着手做一件事情是真的很重要，比如在大二下这学期的数据库的项目中，我就是用了相应的网络编程的知识，所以在这个数据库实验方面达到了较好的效果。\n大二下结束了是暑假，暑假是我觉得最尴尬的一个暑假，我觉得所有问题都来源于自己的判断失误，这个失误我暂且不提，我认为这是我整个学习以来接下的最不好的失误任务（在此打个暗号：机器学习。我至今将无法忘记这件事，真让人感到尴尬），总之就是我当时没有预测到到底能不能得到一定的资源，可惜没有，才导致了整个暑假的打水漂。\n暑假大致主要干了三个事情：背单词，编程，以及unity。对于编程唯一感到可惜的就是没有认真的写letcode的相关题目，失去了这个长时间的机会。对于unity的话，只做了初步了解，并没有过多的深入，感觉还是差一个比较好的教程进行学习。背单词犯了一个比较基本的错误，那就是，应该直接按照单词书上的词汇来背，而不是按照一点都不适合自己的网上的方法进行背单词，这很显然浪费了自己宝贵的时间。\n暑假过后是大三上，从这个时期开始，大学的时光就已经过去一半了，慢慢的，自己也要面临选择的问题了。在这一个学期，单词只背到了25个List（总共30List），这是一个比较遗憾的事情，因为最后的实验报告压力实在巨大，以及外界的影响（说的太好听了，就是不专心），导致单词只背了这么多，很可惜。在这个学期学的课程里面，并没有感到很多有很大实质性的提高，唯一一个感觉就是自己被实验项目压垮的感觉（但是还是自己扛过来了），但是我觉得这个原因还是跟那个原因影响有关，在此我暂且不提，是在是太令人遗憾，以及感到深深的自责。\n对了，还有六级的事情呢，感觉这次六级还是过不了，啊啊啊啊！！\n剩下的就是现在写这个感想的的时间了，现在距离2021结束还剩下一个小时。\n反省对于这一年的种种事情，我认为自己需要认识到几个问题。\n\n第一，我得思考自己到底想要做什么，以及到底想为了什么，而不是一时的头脑冲动，却啥也没有得到。\n第二、在完成一件事情的过程中，得用实质性的东西约束自己认真完成，而不是三天打鱼两天晒网，而不是走马观花，没有一丝认真的态度。总之就是要保证正确的态度去完成任务（说正常点就是不要玩手机，以及看其他无关的东西）。\n第三、正确的去判断某一个东西的好坏，要结合自己的情况，以及当时所处环境的情况，而不是一时头脑发热就答应某些根本不可能完成的问题。\n\n2022想要做的事情\n着手开始考研复习的相关流程，之后会在寒假期间制定相应计划。\n在大三下学期明确自己的方向，以及努力的去寻找并判断好的机会。\n学会独自一个人去教室复习，而不是待在教室，多思考去如何解决。\n完成考研\n通过unity完成一款同人音乐游戏（不求精致，只求学到了什么）。\n在寒假期间练习leetcode的题目，为四月份的蓝桥杯做打算。\n\n总结2021结束了，2022的到来，需要去掉2021的坏习惯，将好的习惯留到下一年继续发扬。不要忘记所有帮助自己的人，要留存着敬畏之心。友善地对待生活中的每一个人，不要去思考与自己无关的事情。\n时刻反省自身，时刻认识到自身的错误，进一步的提高自己。\n抓住机会！\n警惕陷阱！\n","slug":"2021年度总结","date":"2021-12-31T12:34:06.000Z","categories_index":"年度总结","tags_index":"总结","author_index":"懒懒瑭岚"},{"id":"9e81543b01b9fb4d973d1efdec16b262","title":"操作系统期末复习","content":"题型我不知道\nChp1 绪论操作系统的特性：并发、共享、虚拟、异步。\nChp2 操作系统的组织结构操作系统虚拟机什么是操作系统虚拟机？\n在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。\n处理机的状态设置处理机状态的目的？\n为操作系统建立一个保护环境，采用的办法是区分处理机的工作状态。在系统中存在两类程序，一类是管理程序，另一类是用户程序。\n什么是处理机的状态？\n中央处理机的工作状态，当前它正在执行哪类程序，决定处理机的态。\n管态与用户态\n\n管态：又称系统态，是操作系统管理程序执行时机器所处的状态。在此状态下允许中央处理机使用全部系统资源和全部指令（包括一组特权指令），允许访问整个存储区。\n用户态：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。\n\n\n\n\n管态\n用户态\n\n\n\n操作系统的程序执行\n用户程序执行\n\n\n使用全部指令（包括一组特权指令）\n禁止使用特权指令\n\n\n使用全部系统资源（包括整个存储区域）\n只允许用户程序访问自己的存储区域\n\n\n特权指令\n中断技术中断概念\n所谓中断是指某个事件发生时，系统终止现行程序的运行、引出处理该事件程序进行处理，处理完毕后返回断点，继续执行。\n中断类型\n如下列举一个类型，访管中断：对操作系统提出某种需求（如请求I/O传输、建立进程等）时所发出的中断称为访管中断。\n\n按中断功能分类\nI/O中断\n外中断\n机器故障中断\n程序性中断\n访管中断\n\n\n按中断方式进行分类\n强迫性中断\n自愿中断\n\n\n按中断来源分类\n中断（内中断）\n俘获（外中断）\n\n\n\n向量中断什么是向量中断？\n当中断发生时，由中断源引导处理机进入中断服务程序的中断过程称为向量中断。在向量中断中，对于每一个中断类型都设置一个中断向量。\n中断向量\n中断向量就是存储该类型中断的中断服务例行程序的入口地址和处理机状态字的存储单元。系统中的所有中断向量放在一起，形成中断向量表。\n向量中断处理过程\n当发生某一中断事件时，根据该类中断的中断向量直接进入处理该事件的中断处理程序。\nChp3 用户界面系统功能调用什么是系统功能调用？\n白话解释：操作系统设计者编制了一些可以完成用户某些功能的例行子程序（操作系统为用户程序提供服务），这些子程序作为操作系统程序模块的一部分。用户的程序是处于用户态的，用户想要调用则需要采用一种特殊的调用方式–访管方式来实现。使用访管指令进入访管中断。\n系统功能调用的实现\n\n用户程序中：svc n\n访管中断处理程序，保存现场\n例行子程序入口地址表\n例行子程序\n执行完毕后恢复现场\n\nChp4 并发处理顺序执行的特点\n\n\n\n特点名\nxxx\n\n\n\n顺序性\n当顺序程序在处理机上执行时，处理机的操作是严格按照程序所规定的顺序执行的。\n\n\n封闭性\n程序一旦开始执行，其计算结果不受外界因素的影响。\n\n\n可再现性\n程序执行的结果与它的执行速度无关，而只与初始条件有关。\n\n\n什么是并发执行\n若干个程序段同时在系统中运行，这些程序段在执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。\ncobegin;\n\tfun1(),fun2();\ncoend;\n\n并发执行的特点\n\n失去程序的封闭性和再现性\n程序与计算不再一一对应（计算是指在处理机上的执行过程，或处理机按照程序的规定执行操作的过程，是动态的概念）\n程序并发执行的相互制约\n\n进程概念进程的定义\n\n进程是程序的执行\n并行程序称为进程\n进程是可以和别的计算并发的计算\n进程是一个数据结构及在其上进行操作的程序\n进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动\n\n进程的状态\n\n\n\n状态\ninfo\n\n\n\n就绪状态\n当进程获得了除CPU之外的所有资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行\n\n\n运行状态\n得到了中央处理机的控制权，它的程序正在运行\n\n\n等待状态\n若一进程正在等待某一事件发生，而暂时停止执行，这时，即使给它CPU控制权，它也无法执行\n\n\n\n运行状态–&gt;就绪状态：CPU的时间片用完了\n\n进程的构成\n进程=PCB+程序+数据\n进程的描述—进程控制块\n\npcb—process control block\n系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体\n\n什么是线程：所谓线程(thread),从操作系统的管理角度看,就是指”进程的一个可调度实体”,是处理机调度的基本单位:从编程逻辑看,线程是指”程序内部的一个单一的顺序控制流”。\n线程的特点：线程的创建与管理的开销要小得多。进程内可创建多线程。\n线程与进程的区别\n\n调度方面: 线程作为调度分派的基本单位。\n并发性方面: 进程之间可以并发执行。\n拥有资源方面: 进程是拥有资源的基本单位,线程除少量必不可少的资源外,基本上不拥有资源,但它可以访问其隶属进程的资源。\n系统开销: 进程间切换时要涉及到进程环境的切换,开销比较大。而线程间的切换只需保存和设置少量的寄存器内容。因此进程问切换的系统开销远大于线程问切换的系统开销。\n\n进程控制进程控制的概念\n进程控制的职责是对系统中的全部进程实施有效的管理，它是处理机管理的一部分，当系统允许多进程并发执行是，为了实现共享、协调并发进程的关系，处理机管理机就提供对进程实行有效的功能。\n操作系统的核心具有创建、撤销进程和实施进程间同步、通信等功能。\n用于进程控制的原语有：创建原语、撤销原语、阻塞原语、唤醒原语。\n什么是原语？\n原语是一种特殊的系统调用，它可以完成一个特定的功能，一般为外层软件所调用，其特点是原语执行时不可中断，所欲原语操作具有原子性，即它是不在可分的。在操作系统中，原语作为一个基本单位出现的。\n创建原语create\n撤销原语kill\n阻塞原语susp\n唤醒原语wakeup\n进程的相互制约关系资源共享是当代计算机系统的一个重要特征。而资源共享导致进程之间存在相互制约关系。 \n活动的大量的并发进程有着相互制约关系。这种相互制约关系分为两种情况：一种是由于竞争系统资源而引起间接相互制约关系；另一种是由进程之间存在共享数据而引起的直接相互制约关系。\n资源共享的方式\n\n由系统进行统一分配\n由程序自行使用\n\n进程的互斥\n在操作系统中，当某一进程正在访问某一存储区域时，就不允许其它进程来读出或者修改存储区的内容，否则就会发生后果无法估计的错误。我们把进程之间的这种相互制约关系称为互斥。也可以说，进程的互斥是因为对同一物理资源的竞争而产生的相互制约关系。 \n临界资源：通常把一次仅允许一个进程使用的资源称为临界资源。临界区：每个进程中，访问临界资源的那段程序能够从概念上分离出来，称为临界区或临界段。\n进程的同步\n所谓同步，就是并发进程在一些关键点上可能需要相互等待与互通消息，这种相互制约的等待与互通信息称为进程同步。\n同步机构信号和灯P，V操作\n\nP操作：代表资源占用，资源数量减一\nV操作：代表释放资源，资源数量加一\n\n用信号灯实现进程互斥\nmian()\n&#123;\n    int mutex&#x3D;1;\t\t&#x2F;&#x2F;互斥信号灯\n    cobegin\n        p1();\n    \tp2();\n    coend\n&#125;\n\np1()\n&#123;\n    p(mutex);\n    xxx1;\n    v(mutex)\n&#125;\n\np2()\n&#123;\n    p(mutex);\n    xxx2;\n    v(mutex)\n&#125;\n\n用信号灯实现进程同步\nmain()\n&#123;\n    int s1&#x3D;0; &#x2F;*表示有无化验单*&#x2F;\t\n    int s2&#x3D;0; &#x2F;*表示有无化验结果*&#x2F;\n    cobegin\n       \tlabora();\n       \tdiagnosis();\n    coend\n&#125;\n\nlabora ()\n&#123;\n     while(化验工作未完成)\n     &#123;\n        p(s1); \t\t&#x2F;*询问有无化验单，若无则等*&#x2F;\n\t\t化验工作；\n        v (s2); \t&#x2F;*送出化验结果*&#x2F;\n      &#125;\n&#125;\n\ndiagnosis ( )\n&#123;\n      while (看病工作未完成)\n      &#123;\n            看病；\n            v (s1); &#x2F;*送出化验单*&#x2F;\n            p (s2); &#x2F;*等化验结果*&#x2F;\n            diagnosis; &#x2F;*诊断*&#x2F;\n       &#125;\n&#125;\n\n生产者–消费者问题\nmain ( )\n&#123;\nint full&#x3D;0;     &#x2F;*满缓冲区的数目*&#x2F; \nint empty&#x3D;n;     &#x2F;*空缓冲区的数目*&#x2F; \nint mutex&#x3D;1;     &#x2F;*互斥作用*&#x2F;\n  \tcobegin\n        producer ( );\n    \tconsumer( );\n   \tcoend\n&#125;\n\nproducer() \n&#123;\n    while (生产未完成)\n    &#123;\n        ……;\n        生产一个产品;\n        p (empty);\n        p (mutex);\n        送一个产品到有界缓冲区中;\n        v (mutex);\n        v (full);\n    &#125;\n&#125;\nconsumer ( )\n&#123;\n    while (还要继续消费)；\n    &#123;\n        p (full);\n        p (mutex);\n        从有界缓冲区中取产品;\n        v (mutex);\n        v (empty);\n        消费一个产品;\n        ……;\n    &#125;\n&#125;\n\n进程通信xxx（暂且不写）\nChp5 资源分配与调度资源管理的目的\n\n保证资源的高利用率\n在“合理”的时间内使所有的用户有获得资源的机会\n对不可共享的资源实行互斥\n防止由资源分配不当而引起的死锁\n\n资源管理的任务\n\n解决资源分配问题\n资源分配中防止出现死锁\n解决资源的存取、使用方法问题\n提供资源的存取的控制和实施安全保护措施\n\n资源分配机制资源描述器\n描述各类资源的最小分配单位的数据结构称为资源描述器RD（resource descriptor）\n信息资源块\nrib（resource information block）\n\n\n\n等待队列头指针\n\n\n\n可利用资源头指针\n\n\n资源分配程序入口地址\n\n\n资源分配策略先请求先服务\n优先调度\n针对设备特性的调度\n比如磁盘这一类硬件，那么怎么移动磁头也是一种策略。\n死锁什么是死锁?\n死锁是两个或多个进程无止境地等候着永远不会成立的条件的一种系统状态。\n产生死锁的根本原因\n是系统能够提供的资源个数比要求该资源的进程数要少。\n产生死锁的必要条件\n\n互斥条件。在一段时间内，一个资源只能由一个进程独占使用，若别的进程也要求该资源，则须等待直至其占用者释放。\n不剥夺条件。进程所获得的资源在未使用完之前，不能被其它进程强行夺走，而只能由其自行释放。\n占有并等待。进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。\n环路条件。存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。\n\n系统模型\n\n资源请求矩阵\n资源分配矩阵\n\n解决死锁问题的策略\n对于必要条件来说：\n\n破坏互斥条件：可采用假脱机技术。\n破坏部分分配：可采用一次性满足请求，即静态预先分配。\n破坏不剥夺性：可采用可剥夺方法。\n破坏环路条件：可采用检测是否可能出现死锁，再决定是  否进行分配。\n\n策略：\n\n采用资源静态分配方式预防死锁\n采用资源动态分配、有控分配方法来避免死锁\n当死锁发生时检测出死锁，并设法修复。\n忽略死锁，认为死锁不会发生。\n\n死锁的避免\n银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。该算法存在的缺陷：花费的开销大。\n资源的静态分配：资源静态分配策略要求每个过程在开始执行前申请所需的全部资源, 仅在系统为之分配了所需的全部资源后,该进程才开始执行。（就是一开始直接分配全部资源）（破坏了占有并等待）\nChp6 处理机调度处理机的多级调度处理机调度的功能\n\n确定数据结构\n制订调度策略 (调度原则) \n给出调度算法\n具体的实施处理机分派\n\n批处理系统中的处理机调度\n处理机调度分为两级：作业调度和进程调度。作业调度：作业调度又称为宏观调度。对存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。（将程序放到内存）进程调度：进程调度又称为微观调度。对进入主存的所有进程，确定哪个进程在什么时候获得处理机，使用多长时间。（将内存里面的程序放到CPU）\n作业调度作业的状态\n\n提交状态：用户将自己的程序和数据提交给系统，等待输入。\n后备状态：作业已存放在磁盘上，等待调度。\n执行状态：作业进入主存开始运行。 \n完成状态：作业计算完成开始，退出系统。\n\n作业调度的功能\n确定数据结构\n\n建立作业控制块jcb (job control block)：作业控制块记录了每个作业类型、状态、资源请求及分配情况 。 \n确定调度策略与调度算法\n分配资源：为选中的作业分配所需要的系统资源。 \n善后处理：收回该作业所占用的全部资源，撤消作业控制块以及与该作业有关的全部进程。    \n\n调度算法性能的衡量\n\n作业周转时间=完成时间-进入系统的时间\n作业平均周转时间\n带权周转时间=作业周转时间/作业执行时间\n平均带权周转时间\n\n作业调度算法\n\n先来先服务\n\n短作业优先（执行时间短的）\n\n响应比高者优先调度算法：响应比=响应时间/执行事件响应比=1+作业等待时间/执行时间\n\n优先调度算法（对优先级高的作业先调度）\n\n\n进程调度调度/分派结构\n\n调度：在众多处于就绪状态的进程中，按一定的原则选择一个进程。\n分派：当处理机空闲时，是移出就绪队列中第一个进程，并赋予它使用处理机的权利\n\n进程调度方式\n\n非剥夺方式\n剥夺方式\n\n进程调度算法\n\n进程优先数调度算法以静态方式指派给进程称为静态优先数，它一般在进程被创建是确定动态优先数是指在动态的过程中修改进程的优先级。例如，进程优先数随着它占用CPU时间的延长而下降；进程进行I/O操作时，提高优先数。\n循环轮转调度\n多级反馈队列调度\n\n进程状态变迁图\n\n\nChp7 主存管理物理地址：是计算机主存单元的真实地址，又称为绝对地址或实地址。物理地址的集合所对应的空间组成了主存空间。而主存的一个区域是物理地址集合的一个递增整数序列子集所对应的主存空间。\n逻辑地址：用户的程序地址（指令地址或操作数地址）均为逻辑地址。用户程序的所有的逻辑地址集合对应的空间称为作业地址空间\n主存所需要管理的功能\n\n实现逻辑地址到物理主存地址的映射\n主存分配\n存储保护\n主存扩充\n\n主存映射\n\n地址映射：将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程，称为地址映射\n地址映射方式：\n编程或编译时确定地址映射关系\n在作业装入时确定地址映射关系—-静态地址映射\n在程序运行时确定地址映射关系 —-动态地址映射\n\n\n\n主存分配\n\n指定分配策略：主存分配策略、放置策略、调入策略、淘汰策略\n\n存储保护\n程序只能在给定的存储区域内活动。两种方式防止：上下界防护、基址限长寄存器的办法。\n分区存储管理分区分配机构\n\n主存资源信息块\n\n\n\n\n等待队列指针\n\n\n\n空闲区队列指针\n\n\n主存分配程序入口地址\n\n\n\n分区描述器\n\n\n\n\n分配标志（是否被使用）\n\n\n\n分区大小\n\n\n勾链字（对空闲分区而言，为空闲区队列中的勾链字，指向队列中下一个空弦分区，对已分配区而言，此项为零）\n\n\n\n\n分区的分配与回收\n\n分配\n回收：四种情况，上邻空闲区、下邻空闲区、上下邻空闲区、上下邻已分配区。\n\n\n\n放置策略\n\n首次适应算法：按照地址从小到大进行放置\n最佳适应算法：按照空闲空间从小到大进行放置\n最坏适应算法：按照空闲空间从大到小进行放置\n\n页式存储管理页：程序的地址空间被等分成大小相等的片，称为页面，又称为虚页，等于内存上的块\n主存块：主存被等分成大小相等的片，称为主存块，又称为实页\n页表：为了实现从地址空间到物理主存的映象，系统建立的记录页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表。\n为什么要分页\n主要解决的问题就是防止产生更多的分区碎片。\n页式系统需解决那些问题？\n\n页式系统的地址映射\n请调策略\n放置策略\n淘汰策略\n\n内碎片与外碎片\n内碎片：是处于 （操作系统分配的用于装载某一进程的内存）区域内部 的存储块\n外碎片：指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。\n页式地址变换\n\n淘汰策略颠簸：导致系统效率急剧下降的主存和辅存之间的频繁页面置换现象称为颠簸\n置换算法\n\n先进先出算法（FIFO）\n最久未使用淘汰算法（LRU）选择最长时间未被使用的那一页淘汰。计数器：保存一个页存在于主存中的时间，越长代表越久未使用堆栈：每当一个页面被访问过，就立即将它的页号记在页号栈的顶部，而将栈中原有的页号依次下移。这样子，栈最下面的页就是最久未访问的页。\nLRU近似算法：当一个页面被访问，引用位置1，淘汰则选择引用位为0的页面。当然，所有页的引用位会周期性的至0，这样子保证能够有页调出去。\nLFU算法：最不经常使用淘汰算法。\n\n段页式存储管理段号+段内页号+页内位移\n段式系统，它是一个连续的地址空间。分段是一个有意义的信息单位（比如，代码段，数据段，栈段）\nChp8 输入/输出管理什么是设备独立性？\n所谓设备独立性是指，用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。\n逻辑设备名：逻辑设备名，是用户自己指定的设备名(或设备号)，它是暂时的、可更改的。\n物理设备名：物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。\n如何实现设备独立性：为了实现设备的独立性，应引入逻辑设备和物理设备两个概念。在应用程序（用户程序）中，使用逻辑设备名称来请求使用某类设备；而系统执行时，是使用物理设备名称。鉴于驱动程序是一个与硬件（或设备）紧密相关的软件，必须在驱动程序之上设置一层软件，称为设备独立性软件，以执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。\n缓冲技术主要解决问题：解決速度不匹配的问题\n缓冲：缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段\n缓冲器：容量较小，是用来暂时存放数据的一种存储装置\n缓冲区：用来保存在两设备之间或在设备和应用程序之间所传数据的内存区域\n使用缓冲的理由：\n\n缓和CPU与I/O设备速度不匹配的矛盾\n提高它们之间的并行性\n减少对CPU的中断次数，放宽CPU对中断响应时间的要求\n\n设备分配独享设备是指让一个作业在整个运行期间独占使用的设备。独享分配：在一个作业执行前，将它所要使用的设备分配给它；当它结束撤离时，将分配给它的这类设备收回。\n共享设备：由多个作业、进程共同使用的设备称为共享设备。共享分配：共享分配就是动态分配。当进程提出资源申请时，由设备管理模块进行分配，进程使用完毕后，立即归还。\n什么是虚拟技术？\n所谓虚拟技术，是在一类物理设备上模拟另一类物理设备的技术，是将独占设备转化为共享设备的技术\n什么是虚拟设备？\n通常把用来代替独占型设备的那部分外存空间(包括有关的控制表格)称为虚拟设备。\n什么是虚拟分配？\n当进程需要与独占型设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为设备的虚拟分配\nSpooling系统预输入：在作业需要数据前，操作系统已将所需数据预先输入到辅存输入井存放。当作业（或进程）需要数据时，可以从辅存中读入内存\n缓输出：在作业执行时，将输出数据写入辅存输出井中。当作业（或进程）执行完毕（或需要数据时），由操作系统将数据输出\n什么是SPOILING系统\n利用通道、中断技术，在主机控制之下，由通道完成输入输出工作。系统提供一个软件系统(包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行称赞。这一软件系统称为SPOOLING系统 。\n输入输出控制通道的分类：\n\n字节多路通道主要用来连接大量低速设备\n选择通道，常用它来连接单台高速外部设备\n数组多路通道，一般连接中速设备，如磁带机。\n\n通道的意义：不同的通道是为了支持不同速率的设备\nChp9 文件系统文件系统的功能：文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统\n文件系统：文件系统是操作系统中负责管理和存取文件信息的软件机构，它由管理文件所需的数据结构、相应的管理软件，以及访问文件的一组操作组成。\n文件逻辑结构：流式文件、记录式文件。\n文件物理结构：连续文件、串联文件、随机文件、索引文件。\n什么是文件目录：是一张记录所有文件名字以及其存放地址的目录表。表中还应包括关于文件的说明和控制方面信息。\n基本计算题型分析P,V信号灯\n\n\n\n\n\n\n\n\n有一个仓库，可以存放A,B两种产品，但要求：(1)   每次只能存入一种产品（A或B）；(2)    -N&lt;A产品数量-B产品数量&lt;M*其中，N和 M是正整数。使用P、V操作描述产品A和产品B的入库过程。\nInt  mutex&#x3D;1 ;  &#x2F;*互斥信号量*&#x2F;\nInt  sa&#x3D;M-1-(pa-pb);&#x2F;&#x2F;代表pa-pb距离M的差距    &#x2F;*pa,pb为产品A,B的库存数量*&#x2F;\nInt  sb&#x3D;N-1-(pb-pa);&#x2F;&#x2F;代表pa-pb距离N的差距\nMain()\n&#123;  \n    cobegin;\n    inputA();\n    inputB();\n    coend;\n&#125;\ninputA();\n&#123;\n    While(true)\n    &#123;\n        P(sa);\n        P(mutex);\n        产品A入库;\n        V(mutex);\n        V(sb);\n    &#125;\n&#125;\n\ninputB();\n&#123;\n    P(sb);\n    P(mutex);\n    产品B入库;\n    V(mutex);\n    V(sa);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n讨论使用信号量和P、V 操作解决操作系统经典的五个哲学家吃通心面问题（Dijkstra，1965）。有五个哲学家围坐在一圆桌旁，桌子中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后，欲吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。\nmain()\n&#123;\n    int fork[0...4]&#x3D;&#123;1,1,1,1,1,1&#125;;&#x2F;&#x2F;代表叉子的使用情况\n    cobegin\n        p1;p2;p3;p4;p5;\n    coend\n&#125;\n\nprocess Pi   &#x2F;*i&#x3D;0,1,2,3,4 *&#x2F;\n&#123;\n    while()\n    &#123;\n        思考;\n        P(fork[i]);\n        P(fork[i+1] mod 5);\n        吃通心面;\n        V(fork[i]);\n        V(fork[i+1] mod 5);\n    &#125;\n&#125;\n\n总结：\n\n是否存在互斥变量（如果有多个人对同一个物体进行操作时，很显然需要判断是否有互斥）\n存在哪些主体（操作的哪些人）\n被操作物体的数量\n\n资源分配问题+死锁\n\n\n\n\n\n\n\n\n某系统有R1,R2,R3共三种资源，在T0时刻P1,P2,P3,P4这4个进程对资源的占用和需求情况如表所示，此时系统的可用资源向量为（2，1，2）。试问：（1）将系统中各种资源总数和此刻各进程对各种资源的需求数量用向量或矩阵表示出来。（2）如果此时P1,P2均发出资源请求向量request(1,0,1),为了保证系统的安全性，应该如何分配资源给这两个进程？说明你采用策略的原因。（3）如果（2）中两个请求立即得到满足后，系统此刻是否处于死锁状态？\n解答:\n\n对于第一题，直接画个矩阵即可\n按需分配判断，查看剩下的系统资源是否可以满足某个进程的资源请求并释放\n若同时分配给P1、P2进程资源(1,0,1)，则系统剩余资源(0,1,0) 此刻系统并没有立即进入死锁状态，因为这时所有进程没有提出新的资源申请，全部进程均没有因资源请求没得到满足而进入阻塞状态。只有当进程提出资源申请且全部进程都进入阻塞状态时，系统才处于死锁状态。\n\n作业调度+计算时间相关\n\n\n\n\n\n\n\n\n多道程序系统中，供用户使用的内存空间有100KB，磁带机2台，打印机1台。系统采用可变式分区分配方式管理内存，对磁带机和打印机采用静态分配方式，并假设输入/输出操作的时间忽略不计。现有一作业序列如下：\n\n\n\n作业号\n到达时间\n要求计算时间\n要求内存量\n申请磁带机数\n申请打印机数\n\n\n\n1\n8：00\n25分\n15K\n1台\n1台\n\n\n2\n8：20\n10分\n30K\n—\n1台\n\n\n3\n8：20\n20分\n60K\n1台\n—\n\n\n4\n8：30\n20分\n20K\n1台\n—\n\n\n5\n8：35\n15分\n10K\n1台\n1台\n\n\n假设作业调度采用FCFS算法，优先分配内存的低地址区域且不准移动已在内存中的作业，在内存中的作业平分CPU时间，试问：（1）    作业调度的次序是什么？（2）    全部作业运行结束的时刻是什么？（3）    写出所有作业的周转时间及最大的作业周转时间。（4）    平均周转时间是多少？ \n解答:\n\n明确：FCFS叫做”先来先服务“算法。作业在CPU中平分时间，意思就是分时间片，比如A,B在CPU内运行10分钟，相当于A运行了5分钟，B运行了5分钟。优先分配内存的低地址区域（这个与内存调度策略有关了）。\n\n内存页调度问题+计算缺页率\n\n\n\n\n\n\n\n\n已知页面走向为1，2，1，3，1，2，4，2，1，3，4，且开始执行时内存中没有页面。若只给该作业分配2个物理块，当采用FIFO页面淘汰算法时缺页率为多少？假定现有一种淘汰算法，该算法淘汰页面的策略为当需要淘汰页面时，就把刚使用过的页面作为淘汰对象，试问就相同的也面走向，其缺页率又为多少？\n解答:\n\n明确：采用的哪种调度算法，物理块有多大\n思路：绘制表格仔细填写即可\n\n\n\n\n\n\n\n\n\n\n绘制页式转换图\n\n\n根据页式or段页式求物理地址\n\n\n\n\n\n\n\n\n在一个分段存储管理系统中，其段表如表1所示，试求出表2中逻辑地址对应的物理地址。\n表1\n\n\n\n段号\n内存起始地址\n段长\n\n\n\n0\n210\n500\n\n\n1\n2350\n20\n\n\n2\n100\n90\n\n\n3\n1350\n590\n\n\n4\n1938\n95\n\n\n表2\n\n\n\n段号\n段内位移\n物理地址\n\n\n\n0\n430\n\n\n\n1\n10\n\n\n\n2\n500\n\n\n\n3\n400\n\n\n\n4\n112\n\n\n\n5\n32\n\n\n\n解答:\n\n明确：是否为非法地址，是否主存越界\n\n\n\n\n\n\n\n\n\n\n某操作系统采用页式存储管理模式，若该系统允许用户编程空间为32个页面（每页1KB），主存为16KB。如果有一个用户有10页长。某时刻该用户程序页表如下图所示（仅显示已调入内存的页）。若程序遇到以下三个逻辑地址：0AC5H、1AC5H、3AC5H处的操作，试将其分别转化为物理地址，并分析存储管理系统将如何操作。\n\n\n\n逻辑页号\n物理块号\n\n\n\n0\n8\n\n\n1\n7\n\n\n2\n4\n\n\n3\n10\n\n\n注意：缺页中断、越界中断\n技巧：将16进制转换为2进制进行除法。\nCPU利用率\n\n\n\n\n\n\n\n\n设有两个处理机P1，P2，它们各有一个硬件高速缓冲存储器C1，C2，且各有一个主存储器M1，M2，其性能如表所示。假定两个处理机的指令系统相同，它们的指令执行时间与存储器的平均存取周期成正比。如果执行某个程序时，所需的指令或数据在缓冲区中存取到的概率P是0.7，试问这两个处理机速度哪个快？当P=0.9时，处理机的处理速度哪个快？\n\n\n\n\nC1\nC2\nM1\nM2\n\n\n\n存储容量\n4KB\n4KB\n2MB\n2MB\n\n\n存取周期\n60ns\n80ns\n1us\n0.9us\n\n\n解答：\n\n明确：平均存取周期：$$T=T_CP+T_M(1-P)$$其中c与m分别是高速缓冲区，与主存区的存储周期。还有，根据题目意思得，取的指令或数据有两个来源，一个是高速缓冲区，一个是主存区\n\n\n\n\n\n\n\n\n\n\n假设就绪队列中有10个进程，系统将时间片设为200ms,CPU进行进程切换要花费10 ms，试问系统开销所占的比率约为多少？\n解答：\n\n系统开销所占的比率=10/(10+200)=4.8%\n\n文件+目录+大小\n\n\n\n\n\n\n\n\n某文件系统空间的最大容量为4TB（1T=240），以磁盘块为基本分配单位，磁盘块大小为1KB。文件控制块（FCB）包含一个512B的索引表区。请回答下列问题：\n\n假设索引表区仅采用直接索引结构，索引表区存放文件占用的磁盘块号。索引表项中块号最少占多少字节？可支持的单个文件最大长度是多少字节？\n假设索引表区采用如下结构：第0~7字节采用 &lt;起始块号，块数&gt; 格式表示文件创建时预分配的连续存储空间，其中起始块号占6B，块数占2B；剩余504字节采用直接索引结构，一个索引项占6B，则可支持的单个文件最大长度是多少字节？为了使单个文件的长度达到最大，请指出起始块号和块数分别所占字节数的合理值并说明理由。\n\n\n该文件系统空间总的盘块数为4TB/1KB=4G=232个，因此索引表项中块号最少占32/8=4字节。由于索引表区可存放的盘块号最多为512B/4B=128个，因此可支持的单个文件最大长度是128*1KB=128KB。\n\n由于&lt;起始块号，块数&gt; 格式中，块数占2B，因此为文件预分配的连续存储空间最大为2161KB=64MB。直接索引结构部分支持的文件最大长度为（504B/6B）1KB=84KB。综上该地址结构可支持的单个文件最大长度是64MB+84KB=65620KB。\n起始块号和块数分别所占字节数的合理值是 &lt;4, 4&gt; ，块号占4B正好可以表示232个盘块，块数占4B支持的文件最大长度是232*1KB=4TB，正好可以达到文件系统空间的最大容量。\n\n\n理论题汇总板块\n\n\n\n\n\n\n\n\n处理机的管态转变为目态（用户态）是通过设置程序状态字来实现的\n对！\n关键词：管态、目态、程序状态字\n程序状态字：表明系统运行状态的部件是程序状态字，程序状态字PSW（Program Status Word）包括的状态位有进位标志位（CF）、结果为零标志位（ZF）、符号标志位（SF）、溢出标志位（OF）、陷阱标志位（TF）、中断使能（中断屏蔽）标志位（IF）、虚拟中断标志位（VIF）、虚拟中断待决标志位（VIP）、I0特权级别（IOPL）。\n\n\n\n\n\n\n\n\n\n所谓并发是指两个或两个以上进程在同一时刻执行\n错！只要有一小段的时间重合，也可以称之为并发\n关键词：什么是并发\n\n\n\n\n\n\n\n\n\n进程之间存在哪几种相互制约关系？各是由什么原因引起的？\n直接制约关系（同步）、间接制约关系（互斥）。间接制约关系式是存在资源的竞争，直接制约关系是存在资源的共享\n关键词：相互制约关系\n\n\n\n\n\n\n\n\n\n试论述进程与线程在资源拥有和开销的区别\n什么是进程：进程可以认为是程序执行的一个实例，进程是系统进行资源分配的最小单位。\n什么是线程：线程又被称为轻量级的进程，线程是操作系统可识别的最小执行和调度单位。\n进程在资源上的拥有：地址空间、堆、全局变量、栈、寄存器。线程在资源上的拥有：线程栈，寄存器，程序计数器。\n进程的开销大（主要的原因是进程存在页调度），线程的开销小。\n关键词：线程、进程\n\n\n\n\n\n\n\n\n\n分页存储管理需要解决什么问题？试叙述其基本原理。\n（1）需要解决地址映射问题、调度策略、淘汰策略、放置策略。（2）分页存储管理的基本原理是，将程序分成若干个大小相等的页，主存空间分成若干个大小相等的块，然后将页面放到主存块中。\n关键词：分页存储\n\n\n\n\n\n\n\n\n\n解决死锁问题有哪几种策略？他们处理死锁的基本思想是什么？\n（1）预防，采用静态资源分配的方法预防死锁。（2）避免，采用资源动态分类、有控分配方法来避免。（3）检测，当死锁发生时检测出死锁。（4）忽略，认为死锁不会发生。\n关键词：死锁、策略\n附加：死锁产生的四个必要条件。\n\n\n\n\n\n\n\n\n\n何为虚拟设备？请说明Spolling系统是如何实现虚拟设备的。\n（1）通常把用来代替独占型设备的那部分外存空间(包括有关的控制表格)称为虚拟设备。（1）当某进程需要独占型设备交换信息时。Spool系统就将与该独占设备所对应的那部分磁盘、磁鼓的一部分存储控件分配给他。\n关键词：虚拟设备，Spool\n\n\n\n\n\n\n\n\n\n什么是临界资源？什么是临界区？\n（1）是指只允许一个进程使用的资源叫做临界资源。（2）对于每个进程来说，访问临界资源的那段代码称为临界资源。\n关键词：临界资源、临界区\n\n\n\n\n\n\n\n\n\n进程最根本的特性是动态性和独立性\n错！进程最根本的特性是并发性与动态性。\n关键词：进程\n\n\n\n\n\n\n\n\n\n存储管理系统负责管理计算机中所有内、外存空间的分配与管理。\n错！存储管理系统负责计算机内存，文件管理系统负责计算机外存空间\n关键词：内存，存储管理系统\n\n\n\n\n\n\n\n\n\n现代操作系统为什么普遍采用多道程序设计技术，其特点是什么？\n多道程序设计是指在主存中同时存放多道用户作业,它们都处于执行的开始点和结束点之间。多道程序设计的特点如下:\n(1)多道。主存中有多道程序,它们在任一时刻必须处于就绪、运行、阻塞三种状态之一。\n(2)宏观上并行。从宏观上看,它们在同时执行。\n(3)微观上串行。从微观上看,它们在交替、穿插地执行。\n采用多道程序设计后,减少了CPU时间的浪费。尤其对计算题的作业,由于I/O操作较少,CPIJ浪费的时间很少。\n关键词：现代操作系统、多道程序技术\n","slug":"操作系统期末复习","date":"2021-12-31T06:26:35.000Z","categories_index":"学习","tags_index":"学习","author_index":"懒懒瑭岚"},{"id":"85bcb60ef3df802e81a5da2276802e9f","title":"Unity3d关键词汇总","content":"根据类型获取某个对象\n&#x2F;&#x2F;这里我们找的是Canvas这个对象，该函数只找到一个\nCanvas canvas &#x3D; FindObjectOfType&lt;Canvas&gt;();\n\n获取预制体\n&#x2F;&#x2F;获取预制体\n&#x2F;&#x2F;Resources代表必然有一个存在于Assert下的Resources文件夹\n&#x2F;&#x2F;预制体为相对路径\n&#x2F;&#x2F;获取预制体之后，需要注意类型转化的问题\nGameObject mainPanelPrefab &#x3D; (GameObject)Resources.Load(&quot;UIPrefab&#x2F;MainPanel&quot;);\n\n初始化预制体\nGameObject mainPanel&#x3D;Instantiate(mainPanelPrefab);\n\n设置物体的父节点\nmainPanel.transform.SetParent(canvas.transform);\n\n按钮的点击与匿名回调\nButton button &#x3D; GetComponentInChildren&lt;Button&gt;();\nbutton.onClick.AddListener(delegate()&#123;\n    Debug.Log(&quot;这个按钮被点击了&quot;);\n&#125;);\n\n多个的点击与匿名回调\nButton[] btns &#x3D; GetComponentsInChildren&lt;Button&gt;();\nforeach (Button btn in btns)\n&#123;\n  switch (btn.name)\n  &#123;\n    case &quot;GotoAnotherPanelBtn&quot;:\n      btn.onClick.AddListener(delegate ()\n      &#123;\n        Debug.Log(&quot;切换控制面板&quot;);\n      &#125;);\n      break;\n    case &quot;ExitBtn&quot;:\n      btn.onClick.AddListener(delegate ()\n      &#123;\n        Debug.Log(&quot;退出该面板&quot;);\n      &#125;);\n      break;\n  &#125;\n&#125;\n\nUI的隐藏\n&#x2F;&#x2F;将它Destroy\nDestroy(this.gameObject);\n\n&#x2F;&#x2F;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Unity3d关键词汇总","date":"2021-12-28T04:01:19.000Z","categories_index":"Unity3d","tags_index":"Unity3d,学习","author_index":"懒懒瑭岚"},{"id":"045143df31b3074f025eb9e6be112547","title":"java期末复习","content":"题型\n辨析题(对的直接打√，错的打×并改正过来，每小题 2 分，共 20 分)\n简答题(每小题 6 分，共 30 分)\n程序填空题(每空 3 分，共 30 分)\n编程题(每小题 10 分，共 20 分)\n\n复习提纲J2ES部分java 开发环境的下载、安装及配置java的下载\n\n建议下载1.8版本，可以选择压缩包或者安装包下载。使用安装包即可安装。\n\njava环境变量的配置\n# 在系统变量上配置\nJAVA_HOME: \t # 电脑上安装JDK的绝对路径（意思就是这个目录下面包含bin）\nCLASSPATH:   .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n# 在环境变量中配置path\n%JAVA_HOME%\\bin\n%JAVA_HOME%\\jre\\bin\n\n# 编译与运行\njava 运行\njavac 编译\n\njava语言的特性\n\n安全性、可移植性及与平台无关等特性\n\njava虚拟机\n\n在上面运行的是字节码class文件，屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”\n\n垃圾回收\n\n垃圾收集在Java程序运行过程中自动进行，程序员无法精确控制和干预\n\n基本数据类型转换\n容量小的类型自动转换为容量大的数据类型\n数据类型按容量大小排序为byte,short, char-&gt;int-&gt;long-&gt;float-&gt;double\nbyte,short,char之间不会互相转换，他们三者在计算时首先回转换为int类型\n容量大的数据类型转换为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出;使用时要格外注意。\n有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那—种数据类型，然后再进行计算。\n实数常量（如:1.2）默认为double。\n整数常量（如:123）默认为int 。\n\n面向对象编程（有概率为考小题）封装与多态\n\n封装成类\n什么是多态？ 多态是同一个行为具有多个不同表现形式或形态的能力。多态的体现形式：继承、父类引用指向子类、重写。\n\n继承、聚集、实现\n\n继承：extends\n聚集：就是成员变量中使用了其他的类\n\n构造方法\n命名规则\n\n类名的首字母大写\n变量名和方法名的首字母小写\n运用驼峰标识\n\nthis与super\n\nthis为当前对象，super为父类\n\nstatic\n\n在类中，用static声明的成员变量为静态成员变量，它为该类的公用变量，在第一次使用时被初始化，对于该类的所以对象来说，static成员变量只有一份。\n用static声明的方法为静态方法，在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员。\n静态方法不再是针对于某个对象调用，所以不能访问非静态成员\n可以通过对象引用或类名(不需要实例化）访问静态成员。\n\npublic static int a;\npublic static void fun();\n\npackage与import\n\n是为了解决类命名冲突的问题，那么在不同包下，类的名字可以相同。\npackage：打包\nimport：引用\n\npackage com.lltl.service;\n\nimport com.lltl.dao;\n\n关键字this与super\n\nthis是指对象本身\nsuper指向父类\n\n重写\n\n对基类的方法进行重写，或者是实现接口\n关键词@override\n\n权限控制和类的继承\nObject类\n\n里面含有toString方法与equals方法\n\n理解并掌握动态绑定和多态\n\n动态绑定：当调用某个对象的方法时，会从它的继承链向上寻找，若是找到了，则使用。否则继续向父类寻找。\n这类题目我猜测，就是普通类的继承，然后在通过多态的方式进行绑定，如下给个程序例子\n\nclass Shape &#123;\n    void draw() &#123;&#125;\n&#125;\n \nclass Circle extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Circle.draw()\");\n    &#125;\n&#125;\n \nclass Square extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Square.draw()\");\n    &#125;\n&#125;\n \nclass Triangle extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Triangle.draw()\");\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n      show(new Cat());  // 以 Cat 对象调用 show 方法\n      show(new Dog());  // 以 Dog 对象调用 show 方法\n                \n      Animal a = new Cat();  // 向上转型  \n      a.eat();               // 调用的是 Cat 的 eat\n      Cat c = (Cat)a;        // 向下转型  \n      c.work();        // 调用的是 Cat 的 work\n  &#125;  \n            \n    public static void show(Animal a)  &#123;\n      a.eat();  \n        // 类型判断\n        if (a instanceof Cat)  &#123;  // 猫做的事情 \n            Cat c = (Cat)a;  \n            c.work();  \n        &#125; else if (a instanceof Dog) &#123; // 狗做的事情 \n            Dog c = (Dog)a;  \n            c.work();  \n        &#125;  \n    &#125;  \n&#125;\n \nabstract class Animal &#123;  \n    abstract void eat();  \n&#125;  \n  \nclass Cat extends Animal &#123;  \n    public void eat() &#123;  \n        System.out.println(\"吃鱼\");  \n    &#125;  \n    public void work() &#123;  \n        System.out.println(\"抓老鼠\");  \n    &#125;  \n&#125;  \n  \nclass Dog extends Animal &#123;  \n    public void eat() &#123;  \n        System.out.println(\"吃骨头\");  \n    &#125;  \n    public void work() &#123;  \n        System.out.println(\"看家\");  \n    &#125;  \n&#125;\n\nfinal 关键字\n\n在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）\n当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。\n对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。\n方法不能被重写\n\n数组数组的声明\ndataType[] arrayRefVar;   // 首选的方法\n\ndataType[] arrayRefVar = new dataType[arraySize];\n\n//静态初始化\ndataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;\n\n二维数组\n\n注意二维数组不等长特性\n\nint a[][] = new int[3][];\na[0] = new int[2];\na[1] = new int[3];\na[2] = new int[4];\n\n常用类String与StringBuffer的特点以及区别\n\n\n\n\nString\nStringBuffer\n\n\n\n区别\n是对象不是原始类型.\n是一个可变对象,当对他进行修改的时候不会像String那样重新建立对象\n\n\n\n为不可变对象,一旦被创建,就不能修改它的值.\n它只能通过构造函数来建立,\n\n\n\n对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.\nStringBuffer sb = new StringBuffer();\n\n\n\nString 是final类,即不能被继承.\n对象被建立以后,在内存中就会分配内存空间,并初始保存一个null.通过它的append方法向其赋值.sb.append(“hello”);\n\n\n优点\n\n字符串连接操作中StringBuffer的效率要明显比String高\n\n\n\n\nString对象是不可变对象,每次操作Sting 都会重新建立新的对象来保存新的值\n\n\n\n\nStringBuffer对象实例化后，只对这一个对象操作\n\n\nStringBuffer\n\n\n\n方法\n使用\n\n\n\npublic StringBuffer append(String s)\n将指定的字符串追加到此字符序列\n\n\npublic insert(int offset, int i)\n将 int 参数的字符串表示形式插入此序列中\n\n\npublic delete(int start, int end)\n移除此序列的子字符串中的字符\n\n\npublic StringBuffer reverse()\n将此字符序列用其反转形式取代\n\n\n容器类Collection\n\n可以放入不同类型的对象（由于是用Object承接的）\n\nIterator\n\n所有实现了collection接口的容器类都有一个iterator方法用以返回一个实现了Iterator接口的对象。\nIterator对象称作迭代器，用以方便的实现对容器内元素的遍历操作。\nIterator接口定义了如下方法:\n\nboolean hasNext()    //判断游标是否有元素\nObject next();\t\t//返回游标右边的值并且将游标下移一个位置\nvoid remove();\t\t//删除游标左边的元素，当删除了就不能再删除了，除非再次next\n\nSet\n\nSet接口是Collection的子接口，Set接口没有提供额外的方法，但实现Set接口的容器类中的元素是没有有顺序的,而且不可以重复。\nSet容器可以与数学中“集合”的概念相对应。\nJ2SDK API中所提供的 Set容器类有HashSet,TreeSet等。\n\nList\n\nList接口是Collection的子接口，实现List接口的容器类中的元素是有顺序的,而且可以重复。\nList容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\nJ2SDK所提供的List容器类有ArrayList，LinkedList等。\n\nObject get(int index);\nObject set(int index, Object element);\nvoid add(int index, object element);\nObject remove(int index);\nint indexof(Object o);\nint lastIndexof(Object o);\n\nMap\n\n实现Map接口的类用来存储键一值对。\nMap接口的实现类有HashMap和TreeMap等。\nMap类中存储的键一值对通过键来标识，所以键值不能重复。\n\nObject put(Object key, Object value);\nObject get(Object key);\nObject remove(Object key);\nboolean containsKey(Object key);\nboolean containsvalue(Object value);\nint size();\nboolean isEmpty();\nvoid putA11(Map t);\nvoid clear();\n\n迭代器在List、Set、Map的遍历\n//通过迭代器遍历List\nfor(Iterator iter2 = list.iterator();iter2.hasNext();)&#123;\n    String str = (String) iter2.next();\n    System.out.println(str);\n    iter2.remove();\n    iter2.remove();\n&#125;\n\n//通过迭代器遍历Set\nfor(Iterator iter = set.iterator();iter.hasNext();)&#123;\n    String str = (String) iter.next();\n    System.out.println(str);\n&#125;\n\n//遍历Map的第一种方式\nSet keys = map.keySet();\nfor(Iterator iter = keys.iterator();iter.hasNext();)&#123;\n    String keyStr = (String) iter.next();\n    System.out.println(keyStr+\"---\"+map.get(keyStr)); \n&#125;\n\n//遍历Map的第二种方式\nSet&lt;Entry> set2 = map.entrySet();\nfor(Iterator iter = set2.iterator();iter.hasNext();)&#123;\n    Entry e = (Entry) iter.next();\n    System.out.println(e.getKey()+\"---\"+e.getValue());\n&#125;\n\n增强for循环\nint[] numArray = &#123; 1, 2, 3, 4, 5, 6 &#125;;\nfor (int i : numArray) &#123;\n    System.out.print(i);\n&#125;\n\nList、Set、Map 各自的特点及区别\n\n\n\n比较\nList\nSet\nMap\n\n\n\n继承接口\nCollection\nCollection\n\n\n\n常见实现类\nAbstractList(其常用子类有ArrayList、LinkedList、Vector)\nAbstractSet(其常用子类有HashSet、LinkedHashSet、TreeSet)\nHashMap、HashTable\n\n\n常见方法\nadd( )、remove( )、clear( )、get( )、contains( )、size( )\nadd( )、remove( )、clear( )、contains( )、size( )\nput( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )\n\n\n元素\n可重复\n不可重复(用equals()判断)\n不可重复\n\n\n顺序\n有序\n无序(实际上由HashCode决定)\n\n\n\n线程安全\nVector线程安全\n\nHashtable线程安全\n\n\nJ2EE部分TomcatTomcat操作\n\n启动:到tomcat主目录下bin/startup.bat\n停止:到 tomcat主目录下bin/shutdown.bat\n启动:在命令行输入startup或catalina start\n停止:在命令行输入shutdown或catalina stop\n输入http://localhost:8080/，显示如下界面代表安装成功（就是tomcat管理界面）\n\nTomcat的目录层次结构\n\n\n\n目录\n用处\n\n\n\nbin\n存放启动和关闭Tomcat的脚本文件\n\n\nconf\n存放Tomcat服务器的各种配置文件\n\n\nlib\n存放Tomcat服务器的支撑jar包\n\n\nlogs\n存放Tomcat的日志文件\n\n\ntemp\n存放Tomcat运行时产生的临时文件\n\n\nwebapps\nweb应用所在目录，即供外界访问的web资源的存放目录\n\n\nwork\nTomcat的工作目录\n\n\nconf目录下的3个xml文件\n\n\n\nxml\n功能\n\n\n\nsever.xml\n该文件用于配置和server相关的信息,比如tomcat启动端口号,配置Host，配置Context 即web应用\n\n\nweb.xml\n该文件用于配置与web应用(web应用就相当于是一个web站点)相关的信息\n\n\ntomcat-users.xml\n该文件用于配置tomcat的用户角色和密码。\n\n\nWEBB/S结构\n\nBrowser—-WEB—-Database\n优点：开发成本低、管理维护简单、产品升级便利、对用户培训费用低、用户使用方便、出现故障几率小\n缺点：安全性不足、显示效果受浏览器限制\n\n\n\nC/S结构\n\nClient—-Server\n\nServletServlet基本概念\n\nServlet是服务器端的小应用程序\n用来完成B/S架构下，客户端请求的响应处理\n平台独立，性能优良，能以线程方式运行\nServlet API为Servlet提供了统一的编程接口\nServlet一般在容器中运行\n常见的Servlet容器有:TomcatJetty\n\nServlet的分类\n\n普通\n\n一般用作控制器（Controller）\n\n\n过滤\n\n监听\n\n在线计数器\n在线人员列表\n\n\n\nServlet的工作流程（图解）\n\n\nServlet工作原理\n\n工作原理：反射+回调，容器反射出Servlet对象后回调其方法。\n\nServlet生命周期\n\n加载，ClassLoader\n实例化，new\n初始化，init(ServletConfig)\n处理请求，Service-&gt;\\doPost()\\doGet()\n退出服务，destroy()\n\n开发步骤代码赏析\n\nxml部分\n\n&lt;servlet>\n    &lt;!-- 1 -->\n    &lt;servlet-name>GetUserTable&lt;/servlet-name>\n    &lt;!-- 2 -->\n    &lt;servlet-class>com.zsl.controller.GetUserTable&lt;/servlet-class>\n&lt;/servlet>\n\n&lt;servlet-mapping>\n    &lt;!-- 3 -->\n    &lt;servlet-name>GetUserTable&lt;/servlet-name>\n    &lt;!-- 4 -->\n    &lt;url-pattern>/getUserTable&lt;/url-pattern>\n&lt;/servlet-mapping>\n\n&lt;!-- 服务器解析顺序：4->3->1->2 -->\n\n\nservlet部分\n\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    request.setCharacterEncoding(\"utf-8\");\n    response.setContentType(\"text/html;charset=utf-8\");\n    //获取参数\n    String rows = request.getParameter(\"rows\") != null ? request.getParameter(\"rows\") : \"0\";\n    String page = request.getParameter(\"page\") != null ? request.getParameter(\"page\") : \"0\";\n    String sortOrder = request.getParameter(\"sortOrder\") == null ? request.getParameter(\"sortOrder\") : \"asc\";\n    System.out.println(rows + \" \" + page);\n    //查询数据\n    Map&lt;String, String> data = null;\n    try &#123;\n        data = usersService.getUserTableJson(new String[]&#123;rows, page, sortOrder&#125;);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    //返回数据\n    PrintWriter out = response.getWriter();\n    String s = \"&#123;\" +\n        \"\\\"total\\\":\" + \"\\\"\" + data.get(\"total\") + \"\\\"\" + \",\" +\n        \"\\\"rows\\\":\" + data.get(\"rows\") +\n        \"&#125;\";\n    out.write(s);\n&#125;\n\n过滤器运行过程\n\n在一个Web应用中包含多个Filter，组合起来称之为Filter链\nFilter的调用顺序是按照web.xml的注册顺序进行调用的\ndoFilter()\n\n样例代码\n&lt;!-- 过滤器 -->\n&lt;filter>\n    &lt;filter-name>CharacterEncodingFilter&lt;/filter-name>\n    &lt;filter-class>com.zsl.filter.MyEcdFilter&lt;/filter-class>\n    &lt;init-param>\n        &lt;param-name>encode&lt;/param-name>\n        &lt;param-value>utf-8&lt;/param-value>\n    &lt;/init-param>\n&lt;/filter>\n&lt;filter-mapping>\n    &lt;filter-name>CharacterEncodingFilter&lt;/filter-name>\n    &lt;url-pattern>/*&lt;/url-pattern>\n    &lt;!-- 过滤器拦截规则:request过滤器，include过滤器，forward过滤器，error过滤器 -->\n    &lt;dispatcher>REQUEST&lt;/dispatcher>\n    &lt;dispatcher>FORWARD&lt;/dispatcher>\n&lt;/filter-mapping>\n\n监听器三个域对象的监听\n\nServletContext----application\nHttpSession----Sessiom\nServletRequest----request\n\n监听器+Session监听器\npackage com.zsl.listener;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\nimport javax.servlet.http.HttpSessionAttributeListener;\nimport javax.servlet.http.HttpSessionBindingEvent;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@WebListener\npublic class OnlineCountingListener implements ServletContextListener, HttpSessionAttributeListener, HttpSessionListener &#123;\n    ServletContext application = null;\n\n    //监听初始化的时候\n    @Override\n    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;\n        //用一个列表保存用户的信息\n        List&lt;String> list = new ArrayList&lt;String>();\n        //取得Context对象\n        application = servletContextEvent.getServletContext();\n        //将用户列表放入\n        application.setAttribute(\"allUser\", list);\n    &#125;\n\n    //当监听关闭时（服务器被关闭\n    @Override\n    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;\n        System.out.println(\"服务器关闭\");\n    &#125;\n\n    //当Session中添加的新的属性时（也就是有用户登录了\n    @Override\n    public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n        List&lt;String> list = (List&lt;String>) application.getAttribute(\"allUser\");\n        //假设：用户登陆成功之后，只将户名设置到session中\n        if (((String) httpSessionBindingEvent.getName()).equals(\"user\")) &#123;\n            System.out.println(\"添加：\" + (String) httpSessionBindingEvent.getSession().getAttribute(\"user\"));\n            String userName = (String) httpSessionBindingEvent.getSession().getAttribute(\"user\");\n            //取得用户名\n            if (list.indexOf(userName) == -1) &#123;\n                //表示此用户之前没有登陆\n                list.add(userName);\n                application.setAttribute(\"allUser\", list);\n            &#125;\n        &#125;\n    &#125;\n\n    //当Session中某个用户退出登录了\n    @Override\n    public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n        //只对user敏感\n        if (((String) httpSessionBindingEvent.getName()).equals(\"user\")) &#123;\n            List&lt;String> list = (List&lt;String>) application.getAttribute(\"allUser\");\n            System.out.println(\"移出：\" + (String) httpSessionBindingEvent.getValue());\n            list.remove((String) httpSessionBindingEvent.getValue());\n            application.setAttribute(\"allUser\", list);\n        &#125;\n    &#125;\n\n    @Override\n    public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n\n    &#125;\n\n    @Override\n    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;\n\n    &#125;\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;\n\n    &#125;\n&#125;\n\nxml配置\n&lt;listener> \n    &lt;listener-class>com.kiqi.listener.MyListener&lt;/listener-class>\n&lt;/listener>\n\nServletContext\n\n一个web应用对应一个ServletContext，作用于全局\n\nvoid setAttribute(String name,Object value);\nObject getAttribute(String name);\nremoveAttribute(String name);\n\n\n\nCookie&amp;Session二者的区别\n\nCookie保存在客户端\nSession保存在服务端\n\n如何使用Session\n//获取Session\nHttpSession session = request.getSession();\n\n//设置Session\nsession.setAttribute(\"user\", name);\n\n//获取Session里面字段的值\nsession.getAttribute(\"user\");\n\n在服务端操作Cookie\n//获取Cookie，返回的是一个数组\nCookie[] cookies = request.getCookies();\n\n//添加Cookie\nCookie cookie = new Cookie(\"cookieName\", \"cookieValue\");\nresponse.addCookie(cookie);\n\n\n\nJDBC Statement与PreparedStatement的区别\n\nPreperedStatement是Statement的子接口，它的实例对象可以通过调用Connection.prepareStatement()方法获得，相对于Statement对象而言\nPreperedStatement可以避免SQL注入的问题。\nStatement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。PreparedStatement可对SQL进行预编译，从而提高数据库的执行效率。\n并且PreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。\n\n防SQL注入\npublic static ResultSet executeQuery(String sql, Object[] params) &#123;\n    ResultSet rs = null;\n    try &#123;\n        conn = C3P0Util.getConnection();\n        ps = conn.prepareStatement(sql);\n        //对？赋值\n        if (params != null) &#123;\n            for (int i = 0; i &lt; params.length; i++) &#123;\n                ps.setObject(i + 1, params[i]);\n            &#125;\n        &#125;\n        rs = ps.executeQuery();\n    &#125; catch (SQLException e) &#123;\n        e.printStackTrace();\n    &#125;\n    return rs;\n&#125;\n\n前端部分传递表单&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n    Username: &lt;input type=\"text\" name=\"username\">\n    Password: &lt;input type=\"password\" name=\"password\">\n    File: &lt;input type=\"file\" name=\"file\">\n    &lt;input type=\"submit\">\n&lt;/form>\n\n理论问题预测(截取至书本)简述C/S与B/S的区别\n\n硬件环境的不同C/S：一般建立在专用的网络上，小范围里的网络环境、局域网之间再通过专门的服务器提供连接和数据交换服务。B/S：建立在广域网至上的，不必是专门的网络硬件环境，有比C/S更强的适应范围，一般只要有操作系统与浏览器就行。\n对安全要求不同C/S：一般面向相对固定的用户群，对信息安全的控制能力很强，高度机密的信息系统一般采用C/S结构。B/S：建立在广域网之上，对安全的控制能力相对较弱，可能面向不可知的用户。\n对程序架构不同C/S：程序可以更加注重流程，可以对权限多层次校验，对系统运行速度可以较少考虑。B/S：对安全以及访问速度的多重考虑，建立在需要更加优化的基础之上\n软件重用不同C/S：程序可以不可避免地整体新考虑，构建的重用性不如在B/S要求下的构建的重用性好。B/S：对多重结构，要求构建相对独立的功能。\n系统维护不同C/S：程序由于整体性，必须整体考察、处理出现的问题以及系统升级B/S：构件组成，方便个别构件的更换，实现系统的无缝更新。\n处理问题不同C/S：程序可以处理用户面固定，并且在相同区域，安全要求该，与操作系统相关。B/S：建立在广域网之上，面向不同的用户群，地域分散，这是C/S不能做到的\n用户接口不同C/S：多事建立在Windows平台上，表现方法有限，对称需要普遍要求较高。B/S：建立在浏览器上，与用户交流时有更加丰富和生动的表现方式；并且大部分难度降低，降低了开发成本。\n信息流不同C/S：程序一般是典型的重要集权的机械式处理，交互性相对较低。B/S：信息流向可变化，B-B、B-C、B-G等信息，流向的变化，更像是交易中心。\n\n简述一下Servlet作用原理以及生命周期\n\nServlet的工作原理主要是反射+回调。Servlet的执行时其容器如Tomcat通过web.xml的配置反射出Servlet对象后回调其Service方法。目前所有的MVC框架的Controller基本都是这种模式。\nServlet的声明周期主要包括三部分：\n初始化，Web容器加载Servlet，调用init()方法\n处理请求，当请求到达时，运行其Service()方法，Service会自动派遣运行与请求相对应的doPost与doGet\n销毁，服务结束Web容器会调用Servlet的方法销毁Servlet\n\n\n\n简述Filter生命周期的认识\n\n服务器启动的时候，Web服务器会创建Filter的实例对象，并调用其init方法，完成对象的初始化功能。FIlter对象只会创建一次，init方法也只会执行一次。Filter的创建和销毁有Web服务器控制。\n拦截到请求时，执行doFilter方法。可执行多次。\n服务器关闭时，Web服务器销毁Filter的实例对象。\n\n简述Servlet监听器的作用\n\nServlet监听器对特定的事件进行监听，当产生这些事件的时候，会执行监听器的代码。可以是对应的加载、卸载，对Session的初始化、销毁，对Session的初始化、销毁，对Session中值变化等事件进行监听。看，  这\n\n简述MVC的完整流程\n\nMVC（模型、视图、控制器）架构的控制流程为：所有的终端用户的请求被发送到控制器，控制器依赖请求去选择加载哪个模型，并把模型附加到对应的视图，附加了模型数据的最终视图作为响应发送给终端用户。\n\n","slug":"java期末复习","date":"2021-12-27T02:15:41.000Z","categories_index":"学习","tags_index":"学习,java","author_index":"懒懒瑭岚"},{"id":"718afa12fb66304ba8ec0b546fe6aafc","title":"随思所想（二）","content":"考完六级今天考完六级了，总而言之，来年再战（悲），自己的缺陷还很明显，需下次努力\n需完成的目标\n词汇量\n精读，快速阅读文章\n翻译专有词汇\n限时内考核\n\n","slug":"随思所想（二）","date":"2021-12-18T11:41:26.000Z","categories_index":"日记","tags_index":"随思所想","author_index":"懒懒瑭岚"},{"id":"fab7b4dd4790a8b9e5df3ddde73f6c0d","title":"随思所想（一）","content":"作业很多最近的作业很多，包括很多实验项目，都是要在固定时间内完成的。Java一个网页项目，ASP一个网页项目，数据库一个网页项目\nASP的项目真的很累，老师不让用Java写，只让用.NET的框架写。由于当时不知道可以使用.NET core MVC框架来写项目，导致就用了个普通的.ashx一般处理程序来当做后端的API接口。写的真是很累，组内的话只有两个人来写（虽然是五个人的组，但是有些人的能力还是有一点不足，所以就没让他们写），但是另外一个写的朋友，哎~，可能是没时间吧，剩余的接口都没写了，哎，心真的很累。\nJava是一个书城项目，相比于上面的ASP写的方便许多。在组内的管理上（还是上面五个人）比较有进步（虽然大部分还是自己的，就看他们没时间吧）。使用的是纯Servlet+前端的做法，很傻。但是现阶段不想尝试spring-boot了，心累。vue-element还可以接受。\n数据库的的网页项目我加的是另一个组。挺感谢那个组的组长，一个人就把项目写完了（不怎么难），感谢感谢。节省了我大部分时间，我能够有更多的时间完成ASP与java了（哭）。\n其实之前也想跟一些比较厉害的人组队。（因为本人大致会前端后端的相关知识，所以可以很好的听从组长的指挥）但是由于想组队的人都组完了，于是就一个人做全栈了（虽然做的项目也不是什么大项目，也感觉逻辑很傻，需要学习的还很多）\n之后感觉逐渐陷入怠卷了，尽管自己写完了项目，但是还有很多事情就要做（比如明天要考六级），但是自己真的打不起动力来复习（虽然一直在背单词，但是感觉效率很低）于是才有了这篇博客。其实我很希望我自己在完成一件事的时候，能够不看手机。\n哎~我想分析下原因，每当自己想要思考的时候，不自觉的就打开了B站，然后看些没有意义的视频，其实是感到自责的，突然反应过来后，感觉整个人好像落空一般。\n其实还有一点是喜欢自己一个人待在寝室，感觉去教室复习太远了（哎感觉一个人去真的很怕），但是在寝室也可能存在外部的干扰，这一点自己也注意到，正在努力的改正过来。\n反省还是需要用一件事情制约自己。之所以在写博客，正是因为我想放松下自己的心态（明天考六级），但是很显然不是个有效办法，但是这是能找到的最好的办法了。\n感觉自己写博客的时候比较专心吧，能够反省到自己的错误，愿改正。\n希望改正不是一腔热血，这是一个长久的过程，希望自己记住。\n六级加油冲冲冲！！！！！\n","slug":"随思所想（一）","date":"2021-12-17T13:16:24.000Z","categories_index":"日记","tags_index":"随思所想","author_index":"懒懒瑭岚"},{"id":"c2654dc17a414a2cd81c7456edf987f6","title":"欢迎来到懒懒瑭岚的博客","content":"这个博客写的是什么?欢迎来到懒懒瑭岚的博客，博客里面会写写个人日记、开发日记以及相关的技术总结小文章，总之是一个监督自己态度的博客，严于律己。\n目标希望能开发一个同人游戏，学习游戏开发的知识\n现状(2021-12-17)\n哎，还要考六级呢，还有一堆实验报告\n","slug":"欢迎来到懒懒瑭岚的博客","date":"2021-12-17T13:12:30.000Z","categories_index":"博客需知","tags_index":"welcome","author_index":"懒懒瑭岚"},{"id":"9ca1427602c27c6cd9d92e1b88f90384","title":"如何使用hexo","content":"如何生成post页面hexo new post [xxx]\n\n如何使用静态图片首先得把**_config.yml**文件中\npost_asset_folder: true\n\n随后，在新建页面的时候，则会出现相同的文件夹，用于存放静态文件\n注意要找到文件的相对路径，比如我的就是\ncover: /post/如何使用hexo/m005.jpg\n\n如何添加标签与目录tags: # 这是标签\n  - hexo \ncategories: # 这是目录\n  - hexo\n\n","slug":"如何使用hexo","date":"2021-12-17T13:04:50.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"懒懒瑭岚"}]