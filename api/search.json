[{"id":"85bcb60ef3df802e81a5da2276802e9f","title":"Unity3d关键词汇总","content":"根据类型获取某个对象\n&#x2F;&#x2F;这里我们找的是Canvas这个对象，该函数只找到一个\nCanvas canvas &#x3D; FindObjectOfType&lt;Canvas&gt;();\n\n获取预制体\n&#x2F;&#x2F;获取预制体\n&#x2F;&#x2F;Resources代表必然有一个存在于Assert下的Resources文件夹\n&#x2F;&#x2F;预制体为相对路径\n&#x2F;&#x2F;获取预制体之后，需要注意类型转化的问题\nGameObject mainPanelPrefab &#x3D; (GameObject)Resources.Load(&quot;UIPrefab&#x2F;MainPanel&quot;);\n\n初始化预制体\nGameObject mainPanel&#x3D;Instantiate(mainPanelPrefab);\n\n设置物体的父节点\nmainPanel.transform.SetParent(canvas.transform);\n\n","slug":"Unity3d关键词汇总","date":"2021-12-28T04:01:19.000Z","categories_index":"Unity3d","tags_index":"Unity3d,学习","author_index":"懒懒瑭岚"},{"id":"045143df31b3074f025eb9e6be112547","title":"java期末复习","content":"题型\n辨析题(对的直接打√，错的打×并改正过来，每小题 2 分，共 20 分)\n简答题(每小题 6 分，共 30 分)\n程序填空题(每空 3 分，共 30 分)\n编程题(每小题 10 分，共 20 分)\n\n复习提纲J2ES部分java 开发环境的下载、安装及配置\njava的下载建议下载1.8版本，可以选择压缩包或者安装包下载。使用安装包即可安装。\n\njava环境变量的配置：\n# 在系统变量上配置\nJAVA_HOME: \t # 电脑上安装JDK的绝对路径（意思就是这个目录下面包含bin）\nCLASSPATH:   .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n# 在环境变量中配置path\n%JAVA_HOME%\\bin\n%JAVA_HOME%\\jre\\bin\njava语言的特性\n安全性、可移植性及与平台无关等特性\n\njava虚拟机\n在上面运行的是字节码**.class**文件\n\n垃圾回收\n\n\n面向对象编程（有概率为考小题）\n封装与多态\n封装成类\n什么是多态？ 多态是同一个行为具有多个不同表现形式或形态的能力。多态的体现形式：继承、父类引用指向子类、重写。\n\n继承、聚集、实现\n继承：extends\n聚集：就是成员变量中使用了其他的类\n\n构造方法\n\nthis与super\nthis为当前对象，super为父类\n\nstatic-静态变量\n\npackage与import\npackage：打包\nimport：引用\n\n重写\n对基类的方法进行重写，或者是实现接口\n关键词\n@override\n权限控制和类的继承\n\nObject类\n里面含有toString方法与equals方法\n\n理解并掌握动态绑定和多态\n这类题目我猜测，就是普通类的继承，然后在通过多态的方式进行绑定，如下给个程序例子\nclass Shape &#123;\n    void draw() &#123;&#125;\n&#125;\n \nclass Circle extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Circle.draw()\");\n    &#125;\n&#125;\n \nclass Square extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Square.draw()\");\n    &#125;\n&#125;\n \nclass Triangle extends Shape &#123;\n    void draw() &#123;\n        System.out.println(\"Triangle.draw()\");\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n      show(new Cat());  // 以 Cat 对象调用 show 方法\n      show(new Dog());  // 以 Dog 对象调用 show 方法\n                \n      Animal a = new Cat();  // 向上转型  \n      a.eat();               // 调用的是 Cat 的 eat\n      Cat c = (Cat)a;        // 向下转型  \n      c.work();        // 调用的是 Cat 的 work\n  &#125;  \n            \n    public static void show(Animal a)  &#123;\n      a.eat();  \n        // 类型判断\n        if (a instanceof Cat)  &#123;  // 猫做的事情 \n            Cat c = (Cat)a;  \n            c.work();  \n        &#125; else if (a instanceof Dog) &#123; // 狗做的事情 \n            Dog c = (Dog)a;  \n            c.work();  \n        &#125;  \n    &#125;  \n&#125;\n \nabstract class Animal &#123;  \n    abstract void eat();  \n&#125;  \n  \nclass Cat extends Animal &#123;  \n    public void eat() &#123;  \n        System.out.println(\"吃鱼\");  \n    &#125;  \n    public void work() &#123;  \n        System.out.println(\"抓老鼠\");  \n    &#125;  \n&#125;  \n  \nclass Dog extends Animal &#123;  \n    public void eat() &#123;  \n        System.out.println(\"吃骨头\");  \n    &#125;  \n    public void work() &#123;  \n        System.out.println(\"看家\");  \n    &#125;  \n&#125;\nfinal 关键字\n在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）\n当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。\n对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。\n方法不能被重写\n\n\n数组\n数组的声明\ndataType[] arrayRefVar;   // 首选的方法\n\ndataType[] arrayRefVar = new dataType[arraySize];\n\ndataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;\n二维数组\n注意二维数组不等长特性\nint a[][] = new int[3][];\na[0] = new int[2];\na[1] = new int[3];\na[2] = new int[4];\n\n常用类\nString与StringBuffer的特点以及区别\n\n\n\n\nString\nStringBuffer\n\n\n\n区别\n是对象不是原始类型.\n是一个可变对象,当对他进行修改的时候不会像String那样重新建立对象\n\n\n\n为不可变对象,一旦被创建,就不能修改它的值.\n它只能通过构造函数来建立,\n\n\n\n对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.\nStringBuffer sb = new StringBuffer();\n\n\n\nString 是final类,即不能被继承.\n对象被建立以后,在内存中就会分配内存空间,并初始保存一个null.通过它的append方法向其赋值.sb.append(“hello”);\n\n\n优点\n\n字符串连接操作中StringBuffer的效率要明显比String高\n\n\n\n\nString对象是不可变对象,每次操作Sting 都会重新建立新的对象来保存新的值\n\n\n\n\nStringBuffer对象实例化后，只对这一个对象操作\n\n\n\nStringBuffer\n\n\n\n方法\n使用\n\n\n\npublic StringBuffer append(String s)\n将指定的字符串追加到此字符序列\n\n\npublic insert(int offset, int i)\n将 int 参数的字符串表示形式插入此序列中\n\n\npublic delete(int start, int end)\n移除此序列的子字符串中的字符\n\n\npublic StringBuffer reverse()\n将此字符序列用其反转形式取代\n\n\n\n\n容器类\n迭代器\n//通过迭代器遍历List\nfor(Iterator iter2 = list.iterator();iter2.hasNext();)&#123;\n    String str = (String) iter2.next();\n    System.out.println(str);\n    iter2.remove();\n    iter2.remove();\n&#125;\n\n//通过迭代器遍历Set\nfor(Iterator iter = set.iterator();iter.hasNext();)&#123;\n    String str = (String) iter.next();\n    System.out.println(str);\n&#125;\n\n//遍历Map的第一种方式\nSet keys = map.keySet();\nfor(Iterator iter = keys.iterator();iter.hasNext();)&#123;\n    String keyStr = (String) iter.next();\n    System.out.println(keyStr+\"---\"+map.get(keyStr)); \n&#125;\n\n//遍历Map的第二种方式\nSet&lt;Entry> set2 = map.entrySet();\nfor(Iterator iter = set2.iterator();iter.hasNext();)&#123;\n    Entry e = (Entry) iter.next();\n    System.out.println(e.getKey()+\"---\"+e.getValue());\n&#125;\n增强for循环\nint[] numArray = &#123; 1, 2, 3, 4, 5, 6 &#125;;\nfor (int i : numArray) &#123;\n    System.out.print(i);\n&#125;\n List、Set、Map 各自的特点及区别\n\n\n\n\n\n比较\nList\nSet\nMap\n\n\n\n继承接口\nCollection\nCollection\n\n\n\n常见实现类\nAbstractList(其常用子类有ArrayList、LinkedList、Vector)\nAbstractSet(其常用子类有HashSet、LinkedHashSet、TreeSet)\nHashMap、HashTable\n\n\n常见方法\nadd( )、remove( )、clear( )、get( )、contains( )、size( )\nadd( )、remove( )、clear( )、contains( )、size( )\nput( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )\n\n\n元素\n可重复\n不可重复(用equals()判断)\n不可重复\n\n\n顺序\n有序\n无序(实际上由HashCode决定)\n\n\n\n线程安全\nVector线程安全\n\nHashtable线程安全\n\n\nJ2EE部分Tomcat\nB/S结构\nBrowser—-WEB—-Database\n\n\n\n\n​        优点：开发成本低、管理维护简单、产品升级便利、对用户培训费用低、用户使用方便、出现故障几率小\n​        缺点：安全性不足、显示效果受浏览器限制\n\nC/S结构\nClient—-Server\n\n\nServlet\nServlet基本概念\n运行在服务服务端\n\nServlet的分类\n普通、过滤、服务\n\nServlet的工作流程\n\nServlet生命周期\n\n加载，ClassLoader\n实例化，new\n初始化，init(ServletConfig)\n处理请求，Service\\doPost\\doGet\n退出服务，destroy()\n\n\n开发步骤代码赏析\nxml部分\n&lt;servlet>\n    &lt;servlet-name>GetUserTable&lt;/servlet-name>\n    &lt;servlet-class>com.zsl.controller.GetUserTable&lt;/servlet-class>\n&lt;/servlet>\n\n&lt;servlet-mapping>\n    &lt;servlet-name>GetUserTable&lt;/servlet-name>\n    &lt;url-pattern>/getUserTable&lt;/url-pattern>\n&lt;/servlet-mapping>\n\nservlet部分\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    request.setCharacterEncoding(\"utf-8\");\n    response.setContentType(\"text/html;charset=utf-8\");\n    //获取参数\n    String rows = request.getParameter(\"rows\") != null ? request.getParameter(\"rows\") : \"0\";\n    String page = request.getParameter(\"page\") != null ? request.getParameter(\"page\") : \"0\";\n    String sortOrder = request.getParameter(\"sortOrder\") == null ? request.getParameter(\"sortOrder\") : \"asc\";\n    System.out.println(rows + \" \" + page);\n    //查询数据\n    Map&lt;String, String> data = null;\n    try &#123;\n        data = usersService.getUserTableJson(new String[]&#123;rows, page, sortOrder&#125;);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    //返回数据\n    PrintWriter out = response.getWriter();\n    String s = \"&#123;\" +\n        \"\\\"total\\\":\" + \"\\\"\" + data.get(\"total\") + \"\\\"\" + \",\" +\n        \"\\\"rows\\\":\" + data.get(\"rows\") +\n        \"&#125;\";\n    out.write(s);\n&#125;\n\n监听器\n监听器+Session监听器\npackage com.zsl.listener;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\nimport javax.servlet.http.HttpSessionAttributeListener;\nimport javax.servlet.http.HttpSessionBindingEvent;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@WebListener\npublic class OnlineCountingListener implements ServletContextListener, HttpSessionAttributeListener, HttpSessionListener &#123;\n    ServletContext application = null;\n\n    //监听初始化的时候\n    @Override\n    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;\n        //用一个列表保存用户的信息\n        List&lt;String> list = new ArrayList&lt;String>();\n        //取得Context对象\n        application = servletContextEvent.getServletContext();\n        //将用户列表放入\n        application.setAttribute(\"allUser\", list);\n    &#125;\n\n    //当监听关闭时（服务器被关闭\n    @Override\n    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;\n        System.out.println(\"服务器关闭\");\n    &#125;\n\n    //当Session中添加的新的属性时（也就是有用户登录了\n    @Override\n    public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n        List&lt;String> list = (List&lt;String>) application.getAttribute(\"allUser\");\n        //假设：用户登陆成功之后，只将户名设置到session中\n        if (((String) httpSessionBindingEvent.getName()).equals(\"user\")) &#123;\n            System.out.println(\"添加：\" + (String) httpSessionBindingEvent.getSession().getAttribute(\"user\"));\n            String userName = (String) httpSessionBindingEvent.getSession().getAttribute(\"user\");\n            //取得用户名\n            if (list.indexOf(userName) == -1) &#123;\n                //表示此用户之前没有登陆\n                list.add(userName);\n                application.setAttribute(\"allUser\", list);\n            &#125;\n        &#125;\n    &#125;\n\n    //当Session中某个用户退出登录了\n    @Override\n    public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n        //只对user敏感\n        if (((String) httpSessionBindingEvent.getName()).equals(\"user\")) &#123;\n            List&lt;String> list = (List&lt;String>) application.getAttribute(\"allUser\");\n            System.out.println(\"移出：\" + (String) httpSessionBindingEvent.getValue());\n            list.remove((String) httpSessionBindingEvent.getValue());\n            application.setAttribute(\"allUser\", list);\n        &#125;\n    &#125;\n\n    @Override\n    public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) &#123;\n\n    &#125;\n\n    @Override\n    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;\n\n    &#125;\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;\n\n    &#125;\n&#125;\n\nxml配置\n&lt;listener> \n    &lt;listener-class>com.kiqi.listener.MyListener&lt;/listener-class>\n&lt;/listener>\n\nCookie&amp;Session\n二者的区别\nCookie保存在客户端\nSession保存在服务端\n\n如何使用Session\n//获取Session\nHttpSession session = request.getSession();\n//设置Session\nsession.setAttribute(\"user\", name);\n//获取Session里面字段的值\nsession.getAttribute(\"user\");\n\nJDBC\n防SQL注入\nString sql = \"select * from users where uname=? and pwd=?\";\n\n//对？赋值\nif (params != null) &#123;\n    for (int i = 0; i &lt; params.length; i++) &#123;\n        ps.setObject(i + 1, params[i]);\n    &#125;\n&#125;\n\n","slug":"java期末复习","date":"2021-12-27T02:15:41.000Z","categories_index":"学习","tags_index":"学习,java","author_index":"懒懒瑭岚"},{"id":"718afa12fb66304ba8ec0b546fe6aafc","title":"随思所想（二）","content":"考完六级今天考完六级了，总而言之，来年再战（悲），自己的缺陷还很明显，需下次努力\n需完成的目标\n词汇量\n精读，快速阅读文章\n翻译专有词汇\n限时内考核\n\n","slug":"随思所想（二）","date":"2021-12-18T11:41:26.000Z","categories_index":"日记","tags_index":"随思所想","author_index":"懒懒瑭岚"},{"id":"fab7b4dd4790a8b9e5df3ddde73f6c0d","title":"随思所想（一）","content":"作业很多最近的作业很多，包括很多实验项目，都是要在固定时间内完成的。Java一个网页项目，ASP一个网页项目，数据库一个网页项目\nASP的项目真的很累，老师不让用Java写，只让用.NET的框架写。由于当时不知道可以使用.NET core MVC框架来写项目，导致就用了个普通的.ashx一般处理程序来当做后端的API接口。写的真是很累，组内的话只有两个人来写（虽然是五个人的组，但是有些人的能力还是有一点不足，所以就没让他们写），但是另外一个写的朋友，哎~，可能是没时间吧，剩余的接口都没写了，哎，心真的很累。\nJava是一个书城项目，相比于上面的ASP写的方便许多。在组内的管理上（还是上面五个人）比较有进步（虽然大部分还是自己的，就看他们没时间吧）。使用的是纯Servlet+前端的做法，很傻。但是现阶段不想尝试spring-boot了，心累。vue-element还可以接受。\n数据库的的网页项目我加的是另一个组。挺感谢那个组的组长，一个人就把项目写完了（不怎么难），感谢感谢。节省了我大部分时间，我能够有更多的时间完成ASP与java了（哭）。\n其实之前也想跟一些比较厉害的人组队。（因为本人大致会前端后端的相关知识，所以可以很好的听从组长的指挥）但是由于想组队的人都组完了，于是就一个人做全栈了（虽然做的项目也不是什么大项目，也感觉逻辑很傻，需要学习的还很多）\n之后感觉逐渐陷入怠卷了，尽管自己写完了项目，但是还有很多事情就要做（比如明天要考六级），但是自己真的打不起动力来复习（虽然一直在背单词，但是感觉效率很低）于是才有了这篇博客。其实我很希望我自己在完成一件事的时候，能够不看手机。\n哎~我想分析下原因，每当自己想要思考的时候，不自觉的就打开了B站，然后看些没有意义的视频，其实是感到自责的，突然反应过来后，感觉整个人好像落空一般。\n其实还有一点是喜欢自己一个人待在寝室，感觉去教室复习太远了（哎感觉一个人去真的很怕），但是在寝室也可能存在外部的干扰，这一点自己也注意到，正在努力的改正过来。\n反省还是需要用一件事情制约自己。之所以在写博客，正是因为我想放松下自己的心态（明天考六级），但是很显然不是个有效办法，但是这是能找到的最好的办法了。\n感觉自己写博客的时候比较专心吧，能够反省到自己的错误，愿改正。\n希望改正不是一腔热血，这是一个长久的过程，希望自己记住。\n六级加油冲冲冲！！！！！\n","slug":"随思所想（一）","date":"2021-12-17T13:16:24.000Z","categories_index":"日记","tags_index":"随思所想","author_index":"懒懒瑭岚"},{"id":"c2654dc17a414a2cd81c7456edf987f6","title":"欢迎来到懒懒瑭岚的博客","content":"这个博客写的是什么?欢迎来到懒懒瑭岚的博客，博客里面会写写个人日记、开发日记以及相关的技术总结小文章，总之是一个监督自己态度的博客，严于律己。\n目标希望能开发一个同人游戏，学习游戏开发的知识\n现状(2021-12-17)\n哎，还要考六级呢，还有一堆实验报告\n","slug":"欢迎来到懒懒瑭岚的博客","date":"2021-12-17T13:12:30.000Z","categories_index":"博客需知","tags_index":"welcome","author_index":"懒懒瑭岚"},{"id":"9ca1427602c27c6cd9d92e1b88f90384","title":"如何使用hexo","content":"如何生成post页面hexo new post [xxx]\n\n如何使用静态图片首先得把**_config.yml**文件中\npost_asset_folder: true\n\n随后，在新建页面的时候，则会出现相同的文件夹，用于存放静态文件\n注意要找到文件的相对路径，比如我的就是\ncover: /post/如何使用hexo/m005.jpg\n\n如何添加标签与目录tags: # 这是标签\n  - hexo \ncategories: # 这是目录\n  - hexo\n\n","slug":"如何使用hexo","date":"2021-12-17T13:04:50.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"懒懒瑭岚"}]