{"title":"操作系统期末复习","uid":"9e81543b01b9fb4d973d1efdec16b262","slug":"操作系统期末复习","date":"2021-12-31T06:26:35.000Z","updated":"2022-01-01T10:45:07.466Z","comments":true,"path":"api/articles/操作系统期末复习.json","keywords":null,"cover":"/post/随思所想（一）/m007.jpg","content":"<h1 id=\"题型\"><a href=\"#题型\" class=\"headerlink\" title=\"题型\"></a>题型</h1><p>我不知道</p>\n<h1 id=\"Chp1-绪论\"><a href=\"#Chp1-绪论\" class=\"headerlink\" title=\"Chp1 绪论\"></a>Chp1 绪论</h1><p>暂且不整理</p>\n<h1 id=\"Chp2-操作系统的组织结构\"><a href=\"#Chp2-操作系统的组织结构\" class=\"headerlink\" title=\"Chp2 操作系统的组织结构\"></a>Chp2 操作系统的组织结构</h1><h2 id=\"操作系统虚拟机\"><a href=\"#操作系统虚拟机\" class=\"headerlink\" title=\"操作系统虚拟机\"></a>操作系统虚拟机</h2><p><strong>什么是操作系统虚拟机？</strong></p>\n<p>在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。</p>\n<h2 id=\"处理机的状态\"><a href=\"#处理机的状态\" class=\"headerlink\" title=\"处理机的状态\"></a>处理机的状态</h2><p><strong>设置处理机状态的目的？</strong></p>\n<p>为操作系统建立一个保护环境，采用的办法是区分处理机的工作状态。在系统中存在两类程序，一类是管理程序，另一类是用户程序。</p>\n<p><strong>什么是处理机的状态？</strong></p>\n<p>中央处理机的工作状态，当前它正在执行哪类程序，决定处理机的态。</p>\n<p><strong>管态与用户态</strong></p>\n<ul>\n<li><strong>管态</strong>：又称系统态，是<strong>操作系统</strong>管理程序执行时机器所处的状态。在此状态下允许中央处理机使用<strong>全部系统资源</strong>和全部指令（包括一组特权指令），允许访问<strong>整个存储区</strong>。</li>\n<li><strong>用户态</strong>：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">管态</th>\n<th align=\"center\">用户态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">操作系统的程序执行</td>\n<td align=\"center\">用户程序执行</td>\n</tr>\n<tr>\n<td align=\"center\">使用全部指令（包括一组特权指令）</td>\n<td align=\"center\">禁止使用特权指令</td>\n</tr>\n<tr>\n<td align=\"center\">使用全部系统资源（包括整个存储区域）</td>\n<td align=\"center\">只允许用户程序访问自己的存储区域</td>\n</tr>\n</tbody></table>\n<p><strong>特权指令</strong></p>\n<h2 id=\"中断技术\"><a href=\"#中断技术\" class=\"headerlink\" title=\"中断技术\"></a>中断技术</h2><p><strong>中断概念</strong></p>\n<p>所谓中断是指某个事件发生时，系统<strong>终止现行程序</strong>的运行、引出处理该事件程序进行处理，处理完毕后<strong>返回断点</strong>，继续执行。</p>\n<p><strong>中断类型</strong></p>\n<p>如下列举一个类型，<strong>访管中断</strong>：对操作系统提出某种需求（如请求I/O传输、建立进程等）时所发出的中断称为访管中断。</p>\n<h3 id=\"向量中断\"><a href=\"#向量中断\" class=\"headerlink\" title=\"向量中断\"></a>向量中断</h3><p><strong>什么是向量中断？</strong></p>\n<p>当中断发生时，由中断源引导处理机进入终端服务程序的中断过程称为向量中断。在向量中断中，对于每一个中断类型都设置一个中断向量。</p>\n<p><strong>中断向量</strong></p>\n<p>中断向量就是存储该类型<strong>中断的终端服务例行程序的入口地址</strong>和<strong>处理机状态字</strong>的存储单元。<br>系统中的所有中断向量放在一起，形成中断向量表。</p>\n<p><strong>向量中断处理过程</strong></p>\n<p>当发生某一中断事件时，根据该类中断的中断向量直接进入处理该事件的中断处理程序。</p>\n<h1 id=\"Chp3-用户界面\"><a href=\"#Chp3-用户界面\" class=\"headerlink\" title=\"Chp3 用户界面\"></a>Chp3 用户界面</h1><h2 id=\"系统功能调用\"><a href=\"#系统功能调用\" class=\"headerlink\" title=\"系统功能调用\"></a>系统功能调用</h2><p><strong>什么是系统功能调用？</strong></p>\n<p>白话解释：操作系统设计者编制了一些可以完成用户某些功能的例行子程序（操作系统为用户程序提供服务），这些子程序作为操作系统程序模块的一部分。用户的程序是处于用户态的，用户想要调用则需要采用一种特殊的调用方式–访管方式来实现。<strong>使用访管指令进入访管中断</strong>。</p>\n<p><strong>系统功能调用的实现</strong></p>\n<ul>\n<li>用户程序中：<code>svc n</code></li>\n<li>访管中断处理程序，保存现场</li>\n<li>例行子程序入口地址表</li>\n<li>例行子程序</li>\n<li>执行完毕后恢复现场</li>\n</ul>\n<h1 id=\"Chp4-并发处理\"><a href=\"#Chp4-并发处理\" class=\"headerlink\" title=\"Chp4 并发处理\"></a>Chp4 并发处理</h1><p><strong>顺序执行的特点</strong></p>\n<table>\n<thead>\n<tr>\n<th>特点名</th>\n<th>xxx</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>顺序性</td>\n<td></td>\n</tr>\n<tr>\n<td>封闭性</td>\n<td></td>\n</tr>\n<tr>\n<td>可再现性</td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>什么是并发执行</strong></p>\n<p>若干个程序段同时在系统中运行，这些程序段在执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">cobegin;\n\tfun1(),fun2();\ncoend;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>并发执行的特点</strong></p>\n<ul>\n<li>失去程序的封闭性和再现性</li>\n<li>程序与计算不再一一对应（<strong>计算</strong>是指在处理机上的执行过程，或处理机按照程序的规定执行操作的过程，是动态的概念）</li>\n<li>程序并发执行的相互制约</li>\n</ul>\n<h2 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h2><p><strong>进程的定义</strong></p>\n<ul>\n<li>进程是程序的执行</li>\n<li>并行程序称为进程</li>\n<li>进程是可以和别的计算并发的计算</li>\n<li>进程是一个数据结构及在其上进行操作的程序</li>\n<li><strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong></li>\n</ul>\n<p><strong>进程的状态</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>info</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>就绪状态</td>\n<td>当进程获得了除CPU之外的所有资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行</td>\n</tr>\n<tr>\n<td>运行状态</td>\n<td>得到了中央处理机的控制权，它的程序正在运行</td>\n</tr>\n<tr>\n<td>等待状态</td>\n<td>若一进程正在等待某一事件发生，而暂时停止执行，这时，即使给它CPU控制权，它也无法执行</td>\n</tr>\n</tbody></table>\n<ul>\n<li>运行状态–&gt;就绪状态：CPU的时间片用完了</li>\n</ul>\n<p><strong>进程的构成</strong></p>\n<p>进程=PCB+程序+数据</p>\n<p><strong>进程的描述—进程控制块</strong></p>\n<ul>\n<li>pcb—process control block</li>\n<li>系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体</li>\n</ul>\n<p><strong>什么是线程</strong></p>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><p><strong>进程控制的概念</strong></p>\n<p>进程控制的职责是对系统中的全部进程实施有效的管理，它是处理机管理的一部分，当系统允许多进程并发执行是，为了实现共享、协调并发进程的关系，处理机管理机就提供对进程实行有效的功能。</p>\n<p>操作系统的核心具有创建、撤销进程和实施进程间同步、通信等功能。</p>\n<p>用于进程控制的原语有：创建原语、撤销原语、阻塞原语、唤醒原语。</p>\n<p><strong>什么是原语？</strong></p>\n<p>原语是一种特殊的系统调用，它可以完成一个特定的功能，一般为外层软件所调用，其<strong>特点</strong>是原语执行时不可中断，所欲原语操作具有<strong>原子性</strong>，即它是不在可分的。在操作系统中，原语作为一个基本单位出现的。</p>\n<h2 id=\"进程的相互制约关系\"><a href=\"#进程的相互制约关系\" class=\"headerlink\" title=\"进程的相互制约关系\"></a>进程的相互制约关系</h2><p>资源共享是当代计算机系统的一个重要特征。而资源共享导致进程之间存在相互制约关系。 </p>\n<p>活动的大量的并发进程有着相互制约关系。这种相互制约关系分为两种情况：一种是由于竞争系统资源而引起间接相互制约关系；另一种是由进程之间存在共享数据而引起的直接相互制约关系。</p>\n<p><strong>资源共享的方式</strong></p>\n<ol>\n<li>由系统进行统一分配</li>\n<li>由程序自行使用</li>\n</ol>\n<p><strong>进程的互斥</strong></p>\n<p>在操作系统中，当某一进程正在访问某一存储区域时，就不允许其它进程来读出或者修改存储区的内容，否则就会发生后果无法估计的错误。我们把进程之间的这种相互制约关系称为<strong>互斥</strong>。也可以说，<strong>进程的互斥是因为对同一物理资源的竞争而产生的相互制约关系</strong>。 </p>\n<p><strong>临界资源</strong>：通常把一次仅允许一个进程使用的资源称为临界资源。<br><strong>临界区</strong>：每个进程中，访问临界资源的<strong>那段程序</strong>能够从概念上分离出来，称为临界区或临界段。</p>\n<p><strong>进程的同步</strong></p>\n<p>所谓同步，就是并发进程在一些关键点上可能需要相互等待与互通消息，这种相互制约的等待与互通信息称为进程同步。</p>\n<h2 id=\"同步机构\"><a href=\"#同步机构\" class=\"headerlink\" title=\"同步机构\"></a>同步机构</h2><p><strong>信号和灯P，V操作</strong></p>\n<ul>\n<li><strong>P操作</strong>：代表资源占用，资源数量减一</li>\n<li><strong>V操作</strong>：代表释放资源，资源数量加一</li>\n</ul>\n<p><strong>用信号灯实现进程互斥</strong></p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">mian()\n&#123;\n    int mutex&#x3D;1;\t\t&#x2F;&#x2F;互斥信号灯\n    cobegin\n        p1();\n    \tp2();\n    coend\n&#125;\n\np1()\n&#123;\n    p(mutex);\n    xxx1;\n    v(mutex)\n&#125;\n\np2()\n&#123;\n    p(mutex);\n    xxx2;\n    v(mutex)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>用信号灯实现进程同步</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main()\n&#123;\n    int s1&#x3D;0; &#x2F;*表示有无化验单*&#x2F;\t\n    int s2&#x3D;0; &#x2F;*表示有无化验结果*&#x2F;\n    cobegin\n       \tlabora();\n       \tdiagnosis();\n    coend\n&#125;\n\nlabora ()\n&#123;\n     while(化验工作未完成)\n     &#123;\n        p(s1); \t\t&#x2F;*询问有无化验单，若无则等*&#x2F;\n\t\t化验工作；\n        v (s2); \t&#x2F;*送出化验结果*&#x2F;\n      &#125;\n&#125;\n\ndiagnosis ( )\n&#123;\n      while (看病工作未完成)\n      &#123;\n            看病；\n            v (s1); &#x2F;*送出化验单*&#x2F;\n            p (s2); &#x2F;*等化验结果*&#x2F;\n            diagnosis; &#x2F;*诊断*&#x2F;\n       &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>生产者–消费者问题</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main ( )\n&#123;\nint full&#x3D;0;     &#x2F;*满缓冲区的数目*&#x2F; \nint empty&#x3D;n;     &#x2F;*空缓冲区的数目*&#x2F; \nint mutex&#x3D;1;     &#x2F;*互斥作用*&#x2F;\n  \tcobegin\n        producer ( );\n    \tconsumer( );\n   \tcoend\n&#125;\n\nproducer() \n&#123;\n    while (生产未完成)\n    &#123;\n        ……;\n        生产一个产品;\n        p (empty);\n        p (mutex);\n        送一个产品到有界缓冲区中;\n        v (mutex);\n        v (full);\n    &#125;\n&#125;\nconsumer ( )\n&#123;\n    while (还要继续消费)；\n    &#123;\n        p (full);\n        p (mutex);\n        从有界缓冲区中取产品;\n        v (mutex);\n        v (empty);\n        消费一个产品;\n        ……;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><p>xxx（暂且不写）</p>\n<h1 id=\"Chp5-资源分配与调度\"><a href=\"#Chp5-资源分配与调度\" class=\"headerlink\" title=\"Chp5 资源分配与调度\"></a>Chp5 资源分配与调度</h1><p><strong>资源管理的目的</strong></p>\n<ul>\n<li>保证资源的高利用率</li>\n<li>在“合理”的时间内使所有的用户有获得资源的机会</li>\n<li>对不可共享的资源实行互斥</li>\n<li>防止由资源分配不当而引起的死锁</li>\n</ul>\n<p><strong>资源管理的任务</strong></p>\n<ul>\n<li>解决资源分配问题</li>\n<li>资源分配中防止出现死锁</li>\n<li>解决资源的存取、使用方法问题</li>\n<li>提供资源的存取的控制和实施安全保护措施</li>\n</ul>\n<h2 id=\"资源分配机制\"><a href=\"#资源分配机制\" class=\"headerlink\" title=\"资源分配机制\"></a>资源分配机制</h2><p><strong>资源描述器</strong></p>\n<p>描述各类资源的最小分配单位的数据结构称为资源描述器RD（resource descriptor）</p>\n<p><strong>信息资源块</strong></p>\n<p>rib（resource information block）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">等待队列头指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">可利用资源头指针</td>\n</tr>\n<tr>\n<td align=\"left\">资源分配程序入口地址</td>\n</tr>\n</tbody></table>\n<h2 id=\"资源分配策略\"><a href=\"#资源分配策略\" class=\"headerlink\" title=\"资源分配策略\"></a>资源分配策略</h2><p><strong>先请求先服务</strong></p>\n<p><strong>优先调度</strong></p>\n<p><strong>针对设备特性的调度</strong></p>\n<p>比如磁盘这一类硬件，那么怎么移动磁头也是一种策略。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p><strong>什么是死锁?</strong></p>\n<p>死锁是两个或多个进程无止境地等候着永远不会成立的条件的一种系统状态。</p>\n<p><strong>产生死锁的根本原因</strong></p>\n<p>是系统能够<strong>提供的资源</strong>个数比<strong>要求该资源的进程数</strong>要<strong>少</strong>。</p>\n<p><strong>产生死锁的必要条件</strong></p>\n<ul>\n<li>互斥条件。在一段时间内，一个资源只能由一个进程独占使用，若别的进程也要求该资源，则须等待直至其占用者释放。</li>\n<li>不剥夺条件。进程所获得的资源在未使用完之前，不能被其它进程强行夺走，而只能由其自行释放。</li>\n<li>占有并等待。进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。</li>\n<li>环路条件。存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。</li>\n</ul>\n<p><strong>系统模型</strong></p>\n<ul>\n<li>资源请求矩阵</li>\n<li>资源分配矩阵</li>\n</ul>\n<p><strong>解决死锁问题的策略</strong></p>\n<p>对于必要条件来说：</p>\n<ul>\n<li>破坏互斥条件：可采用假脱机技术。</li>\n<li>破坏部分分配：可采用一次性满足请求，即静态预先分配。</li>\n<li>破坏不剥夺性：可采用可剥夺方法。</li>\n<li>破坏环路条件：可采用检测是否可能出现死锁，再决定是  否进行分配。</li>\n</ul>\n<p>策略：</p>\n<ul>\n<li>采用资源静态分配方式预防死锁</li>\n<li>采用资源动态分配、有控分配方法来避免死锁</li>\n<li>当死锁发生时检测出死锁，并设法修复。</li>\n<li>忽略死锁，认为死锁不会发生。</li>\n</ul>\n<p><strong>死锁的避免</strong></p>\n<p>银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。<br>该算法存在的缺陷：花费的<strong>开销大</strong>。</p>\n<h1 id=\"Chp6-处理机调度\"><a href=\"#Chp6-处理机调度\" class=\"headerlink\" title=\"Chp6 处理机调度\"></a>Chp6 处理机调度</h1><h2 id=\"处理机的多级调度\"><a href=\"#处理机的多级调度\" class=\"headerlink\" title=\"处理机的多级调度\"></a>处理机的多级调度</h2><p><strong>处理机调度的功能</strong></p>\n<ul>\n<li>确定数据结构</li>\n<li>制订调度策略 (调度原则) </li>\n<li>给出调度算法</li>\n<li>具体的实施处理机分派</li>\n</ul>\n<p><strong>批处理系统中的处理机调度</strong></p>\n<p>处理机调度分为两级：作业调度和进程调度。<br><strong>作业调度</strong>：作业调度又称为宏观调度。对存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。（将程序放到内存）<br><strong>进程调度</strong>：进程调度又称为微观调度。对进入主存的所有进程，确定哪个进程在什么时候获得处理机，使用多长时间。（将内存里面的程序放到CPU）</p>\n<h2 id=\"作业调度\"><a href=\"#作业调度\" class=\"headerlink\" title=\"作业调度\"></a>作业调度</h2><p><strong>作业的状态</strong></p>\n<ul>\n<li>提交状态：用户将自己的程序和数据提交给系统，等待输入。</li>\n<li>后备状态：作业已存放在磁盘上，等待调度。</li>\n<li>执行状态：作业进入主存开始运行。 </li>\n<li>完成状态：作业计算完成开始，退出系统。</li>\n</ul>\n<p><strong>作业调度的功能</strong></p>\n<p><strong>确定数据结构</strong></p>\n<ol>\n<li>建立作业控制块jcb (job control block)：作业控制块记录了每个作业类型、状态、资源请求及分配情况 。 </li>\n<li>确定调度策略与调度算法</li>\n<li>分配资源：为选中的作业分配所需要的系统资源。 </li>\n<li>善后处理：收回该作业所占用的全部资源，撤消作业控制块以及与该作业有关的全部进程。    </li>\n</ol>\n<p><strong>调度算法性能的衡量</strong></p>\n<ul>\n<li>作业周转时间=完成时间-进入系统的时间</li>\n<li>作业平均周转时间</li>\n<li>带权周转时间=作业周转时间/作业执行时间</li>\n<li>平均带权周转时间</li>\n</ul>\n<p><strong>作业调度算法</strong></p>\n<ul>\n<li><p>先来先服务</p>\n</li>\n<li><p>短作业优先（执行时间短的）</p>\n</li>\n<li><p><strong>响应比高者优先调度算法</strong>：<br>响应比=响应时间/执行事件<br>响应比=1+作业等待时间/执行时间</p>\n</li>\n<li><p>优先调度算法（对优先级高的作业先调度）</p>\n</li>\n</ul>\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p><strong>调度/分派结构</strong></p>\n<ol>\n<li>调度：在众多处于就绪状态的进程中，按一定的原则选择一个进程。</li>\n<li>分派：当处理机空闲时，是移出就绪队列中第一个进程，并赋予它使用处理机的权利</li>\n</ol>\n<p><strong>进程调度方式</strong></p>\n<ul>\n<li>非剥夺方式</li>\n<li>剥夺方式</li>\n</ul>\n<p><strong>进程调度算法</strong></p>\n<ul>\n<li>进程优先数调度算法<br>以静态方式指派给进程称为<strong>静态优先数</strong>，它一般在进程被创建是确定<br><strong>动态优先数</strong>是指在动态的过程中修改进程的优先级。例如，进程优先数随着它占用CPU时间的延长而下降；进程进行I/O操作时，提高优先数。</li>\n<li>循环轮转调度</li>\n<li>多级反馈队列调度</li>\n</ul>\n<p><strong>进程状态变迁图</strong></p>\n<img src=\"/post/操作系统期末复习/image-20220101161341589.png\" alt=\"image-20220101161341589\" style=\"zoom:50%;\" />\n\n<h1 id=\"Chp7-主存管理\"><a href=\"#Chp7-主存管理\" class=\"headerlink\" title=\"Chp7 主存管理\"></a>Chp7 主存管理</h1><p><strong>物理地址</strong>：是计算机主存单元的真实地址，又称为绝对地址或实地址。物理地址的集合所对应的空间组成了<strong>主存空间</strong>。而主存的一个<strong>区域</strong>是物理地址集合的一个递增整数序列子集所对应的主存空间。</p>\n<p>逻辑地址：用户的程序地址（指令地址或操作数地址）均为逻辑地址。用户程序的所有的逻辑地址集合对应的空间称为<strong>作业地址空间</strong></p>\n<p><strong>主存所需要管理的功能</strong></p>\n<ul>\n<li>实现逻辑地址到物理主存地址的映射</li>\n<li>主存分配</li>\n<li>存储保护</li>\n<li>主存扩充</li>\n</ul>\n<p><strong>主存映射</strong></p>\n<ul>\n<li>地址映射：将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程，称为地址映射</li>\n<li>地址映射方式：<ol>\n<li>编程或编译时确定地址映射关系</li>\n<li>在作业装入时确定地址映射关系—-静态地址映射</li>\n<li>在程序运行时确定地址映射关系 —-动态地址映射</li>\n</ol>\n</li>\n</ul>\n<p><strong>主存分配</strong></p>\n<ul>\n<li>指定分配策略：主存分配策略、放置策略、掉入策略、淘汰策略</li>\n</ul>\n<p><strong>存储保护</strong></p>\n<p>不同程序只能使用自己的已分配的主存区域。两种方式防止：上下界防护、基址限长寄存器的办法。</p>\n<h2 id=\"分区存储管理\"><a href=\"#分区存储管理\" class=\"headerlink\" title=\"分区存储管理\"></a>分区存储管理</h2><p><strong>分区分配机构</strong></p>\n<ul>\n<li><p>主存资源信息块</p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th>等待队列指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>空闲区队列指针</td>\n</tr>\n<tr>\n<td>主存分配程序入口地址</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>分区描述器</p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th>分配标志（是否被使用）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>分区大小</td>\n</tr>\n<tr>\n<td>勾链字（对空闲分区而言，为空闲区队列中的勾链字，指向队列中下一个空弦分区，对已分配区而言，此项为零）</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p><strong>分区的分配与回收</strong></p>\n<ul>\n<li>分配</li>\n<li>回收：四种情况，上邻空闲区、下邻空闲区、上下邻空闲区、上下邻已分配区。</li>\n</ul>\n<img src=\"/posts/操作系统期末复习/image-20220101165628326.png\" alt=\"image-20220101165628326\" style=\"zoom:80%;\" />\n\n<p><strong>放置策略</strong></p>\n<ul>\n<li>首次适应算法：按照<strong>地址从小到大</strong>进行放置</li>\n<li>最佳适应算法：按照<strong>空闲控件从小到大</strong>进行放置</li>\n<li>最坏适应算法：按照<strong>空闲控件从大到小</strong>进行放置</li>\n</ul>\n<h2 id=\"页式存储管理\"><a href=\"#页式存储管理\" class=\"headerlink\" title=\"页式存储管理\"></a>页式存储管理</h2><p><strong>页</strong>：程序的地址空间被等分成大小相等的片，称为页面，又称为虚页</p>\n<p><strong>主存块</strong>：主存被等分成大小相等的片，称为主存块，又称为实页</p>\n<p><strong>页表</strong>：为了实现从地址空间到物理主存的映象，系统建立的记录页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表。</p>\n<p><strong>为什么要分页</strong></p>\n<p>主要解决的问题就是防止产生更多的分区碎片，</p>\n","text":"题型我不知道 Chp1 绪论暂且不整理 Chp2 操作系统的组织结构操作系统虚拟机什么是操作系统虚拟机？ 在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。 处理机的状态设置处理机状态的目的？ 为操作系统建立一个保护...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"学习","slug":"学习","count":2,"path":"api/categories/学习.json"}],"tags":[{"name":"学习","slug":"学习","count":3,"path":"api/tags/学习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">题型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp1-%E7%BB%AA%E8%AE%BA\"><span class=\"toc-text\">Chp1 绪论</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Chp2 操作系统的组织结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">操作系统虚拟机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">处理机的状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">中断技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">向量中断</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp3-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">Chp3 用户界面</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">系统功能调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp4-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Chp4 并发处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">进程概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">进程控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">进程的相互制约关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">同步机构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程通信</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp5-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">Chp5 资源分配与调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">资源分配机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">资源分配策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp6-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">Chp6 处理机调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E5%A4%9A%E7%BA%A7%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">处理机的多级调度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">作业调度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">进程调度</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp7-%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">Chp7 主存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">分区存储管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">页式存储管理</span></a></li></ol></li></ol>","author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"2021年度总结","uid":"10e799bf47669bd7fff35712248e1c6e","slug":"2021年度总结","date":"2021-12-31T12:34:06.000Z","updated":"2021-12-31T15:15:35.343Z","comments":true,"path":"api/articles/2021年度总结.json","keywords":null,"cover":"/post/2021年度总结/u=3715033498,2456029672&fm=253&fmt=auto&app=120&f=JPEG.webp","text":"引言这是我第一次写年度总结在自己的博客上面，用来总结这一年到底干了什么，以及需要改进的是什么。2021年对我来说是一个过渡期，可能是让我更加明确自己方向的一个时期，但是在这方面还是拥有一点疑虑，需要再深思熟虑。 2021年做了什么？其实大致的忘了自己2021年开始到底做了什么，因...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"年度总结","slug":"年度总结","count":1,"path":"api/categories/年度总结.json"}],"tags":[{"name":"总结","slug":"总结","count":1,"path":"api/tags/总结.json"}],"author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Unity3d关键词汇总","uid":"85bcb60ef3df802e81a5da2276802e9f","slug":"Unity3d关键词汇总","date":"2021-12-28T04:01:19.000Z","updated":"2021-12-29T15:02:02.242Z","comments":true,"path":"api/articles/Unity3d关键词汇总.json","keywords":null,"cover":"/post/Unity3d关键词汇总/m001.jpg","text":"根据类型获取某个对象 &#x2F;&#x2F;这里我们找的是Canvas这个对象，该函数只找到一个 Canvas canvas &#x3D; FindObjectOfType&lt;Canvas&gt;(); 获取预制体 &#x2F;&#x2F;获取预制体 &#x2F;&#x2F...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"Unity3d","slug":"Unity3d","count":1,"path":"api/categories/Unity3d.json"}],"tags":[{"name":"Unity3d","slug":"Unity3d","count":1,"path":"api/tags/Unity3d.json"},{"name":"学习","slug":"学习","count":3,"path":"api/tags/学习.json"}],"author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}