{"title":"操作系统期末复习","uid":"9e81543b01b9fb4d973d1efdec16b262","slug":"操作系统期末复习","date":"2021-12-31T06:26:35.000Z","updated":"2022-01-06T03:53:10.102Z","comments":true,"path":"api/articles/操作系统期末复习.json","keywords":null,"cover":"/post/随思所想（一）/m007.jpg","content":"<h1 id=\"题型\"><a href=\"#题型\" class=\"headerlink\" title=\"题型\"></a>题型</h1><p>我不知道</p>\n<h1 id=\"Chp1-绪论\"><a href=\"#Chp1-绪论\" class=\"headerlink\" title=\"Chp1 绪论\"></a>Chp1 绪论</h1><p><strong>操作系统的特性</strong>：并发、共享、虚拟、异步。</p>\n<h1 id=\"Chp2-操作系统的组织结构\"><a href=\"#Chp2-操作系统的组织结构\" class=\"headerlink\" title=\"Chp2 操作系统的组织结构\"></a>Chp2 操作系统的组织结构</h1><h2 id=\"操作系统虚拟机\"><a href=\"#操作系统虚拟机\" class=\"headerlink\" title=\"操作系统虚拟机\"></a>操作系统虚拟机</h2><p><strong>什么是操作系统虚拟机？</strong></p>\n<p>在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。</p>\n<h2 id=\"处理机的状态\"><a href=\"#处理机的状态\" class=\"headerlink\" title=\"处理机的状态\"></a>处理机的状态</h2><p><strong>设置处理机状态的目的？</strong></p>\n<p>为操作系统建立一个保护环境，采用的办法是区分处理机的工作状态。在系统中存在两类程序，一类是管理程序，另一类是用户程序。</p>\n<p><strong>什么是处理机的状态？</strong></p>\n<p>中央处理机的工作状态，当前它正在执行哪类程序，决定处理机的态。</p>\n<p><strong>管态与用户态</strong></p>\n<ul>\n<li><strong>管态</strong>：又称系统态，是<strong>操作系统</strong>管理程序执行时机器所处的状态。在此状态下允许中央处理机使用<strong>全部系统资源</strong>和全部指令（包括一组特权指令），允许访问<strong>整个存储区</strong>。</li>\n<li><strong>用户态</strong>：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">管态</th>\n<th align=\"center\">用户态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">操作系统的程序执行</td>\n<td align=\"center\">用户程序执行</td>\n</tr>\n<tr>\n<td align=\"center\">使用全部指令（包括一组特权指令）</td>\n<td align=\"center\">禁止使用特权指令</td>\n</tr>\n<tr>\n<td align=\"center\">使用全部系统资源（包括整个存储区域）</td>\n<td align=\"center\">只允许用户程序访问自己的存储区域</td>\n</tr>\n</tbody></table>\n<p><strong>特权指令</strong></p>\n<h2 id=\"中断技术\"><a href=\"#中断技术\" class=\"headerlink\" title=\"中断技术\"></a>中断技术</h2><p><strong>中断概念</strong></p>\n<p>所谓中断是指某个事件发生时，系统<strong>终止现行程序</strong>的运行、引出处理该事件程序进行处理，处理完毕后<strong>返回断点</strong>，继续执行。</p>\n<p><strong>中断类型</strong></p>\n<p>如下列举一个类型，<strong>访管中断</strong>：对操作系统提出某种需求（如请求I/O传输、建立进程等）时所发出的中断称为访管中断。</p>\n<ol>\n<li>按中断功能分类<ul>\n<li>I/O中断</li>\n<li>外中断</li>\n<li>机器故障中断</li>\n<li>程序性中断</li>\n<li>访管中断</li>\n</ul>\n</li>\n<li>按中断方式进行分类<ul>\n<li>强迫性中断</li>\n<li>自愿中断</li>\n</ul>\n</li>\n<li>按中断来源分类<ul>\n<li>中断（内中断）</li>\n<li>俘获（外中断）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"向量中断\"><a href=\"#向量中断\" class=\"headerlink\" title=\"向量中断\"></a>向量中断</h3><p><strong>什么是向量中断？</strong></p>\n<p>当中断发生时，由<strong>中断源</strong>引导处理机进入<strong>中断服务程序</strong>的中断过程称为向量中断。在向量中断中，对于每一个中断类型都设置一个中断向量。</p>\n<p><strong>中断向量</strong></p>\n<p>中断向量就是存储该类型中断的<strong>中断服务例行程序</strong>的<strong>入口地址</strong>和<strong>处理机状态字</strong>的存储单元。<br>系统中的所有中断向量放在一起，形成中断向量表。</p>\n<p><strong>向量中断处理过程</strong></p>\n<p>当发生某一中断事件时，根据该类中断的中断向量直接进入处理该事件的中断处理程序。</p>\n<h1 id=\"Chp3-用户界面\"><a href=\"#Chp3-用户界面\" class=\"headerlink\" title=\"Chp3 用户界面\"></a>Chp3 用户界面</h1><h2 id=\"系统功能调用\"><a href=\"#系统功能调用\" class=\"headerlink\" title=\"系统功能调用\"></a>系统功能调用</h2><p><strong>什么是系统功能调用？</strong></p>\n<p>白话解释：操作系统设计者编制了一些可以完成用户某些功能的例行子程序（操作系统为用户程序提供服务），这些子程序作为操作系统程序模块的一部分。用户的程序是处于用户态的，用户想要调用则需要采用一种特殊的调用方式–访管方式来实现。<strong>使用访管指令进入访管中断</strong>。</p>\n<p><strong>系统功能调用的实现</strong></p>\n<ul>\n<li>用户程序中：<code>svc n</code></li>\n<li>访管中断处理程序，保存现场</li>\n<li>例行子程序入口地址表</li>\n<li>例行子程序</li>\n<li>执行完毕后恢复现场</li>\n</ul>\n<h1 id=\"Chp4-并发处理\"><a href=\"#Chp4-并发处理\" class=\"headerlink\" title=\"Chp4 并发处理\"></a>Chp4 并发处理</h1><p><strong>顺序执行的特点</strong></p>\n<table>\n<thead>\n<tr>\n<th>特点名</th>\n<th>xxx</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>顺序性</td>\n<td>当顺序程序在处理机上执行时，处理机的操作是严格按照程序所规定的顺序执行的。</td>\n</tr>\n<tr>\n<td>封闭性</td>\n<td>程序一旦开始执行，其计算结果不受外界因素的影响。</td>\n</tr>\n<tr>\n<td>可再现性</td>\n<td>程序执行的结果与它的执行速度无关，而只与初始条件有关。</td>\n</tr>\n</tbody></table>\n<p><strong>什么是并发执行</strong></p>\n<p>若干个程序段同时在系统中运行，这些程序段在执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">cobegin;\n\tfun1(),fun2();\ncoend;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>并发执行的特点</strong></p>\n<ul>\n<li>失去程序的封闭性和再现性</li>\n<li>程序与计算不再一一对应（<strong>计算</strong>是指在处理机上的执行过程，或处理机按照程序的规定执行操作的过程，是动态的概念）</li>\n<li>程序并发执行的相互制约</li>\n</ul>\n<h2 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h2><p><strong>进程的定义</strong></p>\n<ul>\n<li>进程是程序的执行</li>\n<li>并行程序称为进程</li>\n<li>进程是可以和别的计算并发的计算</li>\n<li>进程是一个数据结构及在其上进行操作的程序</li>\n<li><strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong></li>\n</ul>\n<p><strong>进程的状态</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>info</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>就绪状态</td>\n<td>当进程获得了除CPU之外的所有资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行</td>\n</tr>\n<tr>\n<td>运行状态</td>\n<td>得到了中央处理机的控制权，它的程序正在运行</td>\n</tr>\n<tr>\n<td>等待状态</td>\n<td>若一进程正在等待某一事件发生，而暂时停止执行，这时，即使给它CPU控制权，它也无法执行</td>\n</tr>\n</tbody></table>\n<ul>\n<li>运行状态–&gt;就绪状态：CPU的时间片用完了</li>\n</ul>\n<p><strong>进程的构成</strong></p>\n<p>进程=PCB+程序+数据</p>\n<p><strong>进程的描述—进程控制块</strong></p>\n<ul>\n<li>pcb—process control block</li>\n<li>系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体</li>\n</ul>\n<p><strong>什么是线程</strong>：所谓线程(thread),从操作系统的管理角度看,就是指”进程的一个可调度实体”,是处理机调度的基本单位:从编程逻辑看,线程是指”程序内部的一个单一的顺序控制流”。</p>\n<p><strong>线程的特点</strong>：线程的创建与管理的开销要小得多。进程内可创建多线程。</p>\n<p><strong>线程与进程的区别</strong></p>\n<ul>\n<li>调度方面: 线程作为调度分派的基本单位。</li>\n<li>并发性方面: 进程之间可以并发执行。</li>\n<li>拥有资源方面: 进程是拥有资源的基本单位,线程除少量必不可少的资源外,基本上不拥有资源,但它可以访问其隶属进程的资源。</li>\n<li>系统开销: 进程间切换时要涉及到进程环境的切换,开销比较大。而线程间的切换只需保存和设置少量的寄存器内容。因此进程问切换的系统开销远大于线程问切换的系统开销。</li>\n</ul>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><p><strong>进程控制的概念</strong></p>\n<p>进程控制的职责是对系统中的全部进程实施有效的管理，它是处理机管理的一部分，当系统允许多进程并发执行是，为了实现共享、协调并发进程的关系，处理机管理机就提供对进程实行有效的功能。</p>\n<p>操作系统的核心具有<strong>创建</strong>、<strong>撤销</strong>进程和实施进程间同步、通信等功能。</p>\n<p>用于进程控制的原语有：创建原语、撤销原语、阻塞原语、唤醒原语。</p>\n<p><strong>什么是原语？</strong></p>\n<p>原语是一种特殊的系统调用，它可以完成一个特定的功能，一般为外层软件所调用，其<strong>特点</strong>是原语执行时不可中断，所欲原语操作具有<strong>原子性</strong>，即它是不在可分的。在操作系统中，原语作为一个基本单位出现的。</p>\n<p><strong>创建原语create</strong></p>\n<p><strong>撤销原语kill</strong></p>\n<p><strong>阻塞原语susp</strong></p>\n<p><strong>唤醒原语wakeup</strong></p>\n<h2 id=\"进程的相互制约关系\"><a href=\"#进程的相互制约关系\" class=\"headerlink\" title=\"进程的相互制约关系\"></a>进程的相互制约关系</h2><p>资源共享是当代计算机系统的一个重要特征。而资源共享导致进程之间存在相互制约关系。 </p>\n<p>活动的大量的并发进程有着相互制约关系。这种相互制约关系分为两种情况：一种是由于<strong>竞争</strong>系统资源而引起间接相互制约关系；另一种是由进程之间存在<strong>共享</strong>数据而引起的直接相互制约关系。</p>\n<p><strong>资源共享的方式</strong></p>\n<ol>\n<li>由系统进行统一分配</li>\n<li>由程序自行使用</li>\n</ol>\n<p><strong>进程的互斥</strong></p>\n<p>在操作系统中，当某一进程正在访问某一存储区域时，就不允许其它进程来读出或者修改存储区的内容，否则就会发生后果无法估计的错误。我们把进程之间的这种相互制约关系称为<strong>互斥</strong>。也可以说，<strong>进程的互斥是因为对同一物理资源的竞争而产生的相互制约关系</strong>。 </p>\n<p><strong>临界资源</strong>：通常把一次仅允许一个进程使用的资源称为临界资源。<br><strong>临界区</strong>：每个进程中，访问临界资源的<strong>那段程序</strong>能够从概念上分离出来，称为临界区或临界段。</p>\n<p><strong>进程的同步</strong></p>\n<p>所谓同步，就是并发进程在一些关键点上可能需要<strong>相互等待</strong>与<strong>互通消息</strong>，这种相互制约的等待与互通信息称为进程同步。</p>\n<h2 id=\"同步机构\"><a href=\"#同步机构\" class=\"headerlink\" title=\"同步机构\"></a>同步机构</h2><p><strong>信号和灯P，V操作</strong></p>\n<ul>\n<li><strong>P操作</strong>：代表资源占用，资源数量减一</li>\n<li><strong>V操作</strong>：代表释放资源，资源数量加一</li>\n</ul>\n<p><strong>用信号灯实现进程互斥</strong></p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">mian()\n&#123;\n    int mutex&#x3D;1;\t\t&#x2F;&#x2F;互斥信号灯\n    cobegin\n        p1();\n    \tp2();\n    coend\n&#125;\n\np1()\n&#123;\n    p(mutex);\n    xxx1;\n    v(mutex)\n&#125;\n\np2()\n&#123;\n    p(mutex);\n    xxx2;\n    v(mutex)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>用信号灯实现进程同步</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main()\n&#123;\n    int s1&#x3D;0; &#x2F;*表示有无化验单*&#x2F;\t\n    int s2&#x3D;0; &#x2F;*表示有无化验结果*&#x2F;\n    cobegin\n       \tlabora();\n       \tdiagnosis();\n    coend\n&#125;\n\nlabora ()\n&#123;\n     while(化验工作未完成)\n     &#123;\n        p(s1); \t\t&#x2F;*询问有无化验单，若无则等*&#x2F;\n\t\t化验工作；\n        v (s2); \t&#x2F;*送出化验结果*&#x2F;\n      &#125;\n&#125;\n\ndiagnosis ( )\n&#123;\n      while (看病工作未完成)\n      &#123;\n            看病；\n            v (s1); &#x2F;*送出化验单*&#x2F;\n            p (s2); &#x2F;*等化验结果*&#x2F;\n            diagnosis; &#x2F;*诊断*&#x2F;\n       &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>生产者–消费者问题</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main ( )\n&#123;\nint full&#x3D;0;     &#x2F;*满缓冲区的数目*&#x2F; \nint empty&#x3D;n;     &#x2F;*空缓冲区的数目*&#x2F; \nint mutex&#x3D;1;     &#x2F;*互斥作用*&#x2F;\n  \tcobegin\n        producer ( );\n    \tconsumer( );\n   \tcoend\n&#125;\n\nproducer() \n&#123;\n    while (生产未完成)\n    &#123;\n        ……;\n        生产一个产品;\n        p (empty);\n        p (mutex);\n        送一个产品到有界缓冲区中;\n        v (mutex);\n        v (full);\n    &#125;\n&#125;\nconsumer ( )\n&#123;\n    while (还要继续消费)；\n    &#123;\n        p (full);\n        p (mutex);\n        从有界缓冲区中取产品;\n        v (mutex);\n        v (empty);\n        消费一个产品;\n        ……;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><p>xxx（暂且不写）</p>\n<h1 id=\"Chp5-资源分配与调度\"><a href=\"#Chp5-资源分配与调度\" class=\"headerlink\" title=\"Chp5 资源分配与调度\"></a>Chp5 资源分配与调度</h1><p><strong>资源管理的目的</strong></p>\n<ul>\n<li>保证资源的高利用率</li>\n<li>在“合理”的时间内使所有的用户有获得资源的机会</li>\n<li>对不可共享的资源实行互斥</li>\n<li>防止由资源分配不当而引起的死锁</li>\n</ul>\n<p><strong>资源管理的任务</strong></p>\n<ul>\n<li>解决资源分配问题</li>\n<li>资源分配中防止出现死锁</li>\n<li>解决资源的存取、使用方法问题</li>\n<li>提供资源的存取的控制和实施安全保护措施</li>\n</ul>\n<h2 id=\"资源分配机制\"><a href=\"#资源分配机制\" class=\"headerlink\" title=\"资源分配机制\"></a>资源分配机制</h2><p><strong>资源描述器</strong></p>\n<p>描述各类资源的最小分配单位的数据结构称为资源描述器RD（resource descriptor）</p>\n<p><strong>信息资源块</strong></p>\n<p>rib（resource information block）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">等待队列头指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">可利用资源头指针</td>\n</tr>\n<tr>\n<td align=\"left\">资源分配程序入口地址</td>\n</tr>\n</tbody></table>\n<h2 id=\"资源分配策略\"><a href=\"#资源分配策略\" class=\"headerlink\" title=\"资源分配策略\"></a>资源分配策略</h2><p><strong>先请求先服务</strong></p>\n<p><strong>优先调度</strong></p>\n<p><strong>针对设备特性的调度</strong></p>\n<p>比如磁盘这一类硬件，那么怎么移动磁头也是一种策略。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p><strong>什么是死锁?</strong></p>\n<p>死锁是两个或多个进程无止境地等候着永远不会成立的条件的一种系统状态。</p>\n<p><strong>产生死锁的根本原因</strong></p>\n<p>是系统能够<strong>提供的资源</strong>个数比<strong>要求该资源的进程数</strong>要<strong>少</strong>。</p>\n<p><strong>产生死锁的必要条件</strong></p>\n<ul>\n<li>互斥条件。在一段时间内，一个资源只能由一个进程独占使用，若别的进程也要求该资源，则须等待直至其占用者释放。</li>\n<li>不剥夺条件。进程所获得的资源在未使用完之前，不能被其它进程强行夺走，而只能由其自行释放。</li>\n<li>占有并等待。进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。</li>\n<li>环路条件。存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。</li>\n</ul>\n<p><strong>系统模型</strong></p>\n<ul>\n<li>资源请求矩阵</li>\n<li>资源分配矩阵</li>\n</ul>\n<p><strong>解决死锁问题的策略</strong></p>\n<p>对于必要条件来说：</p>\n<ul>\n<li>破坏互斥条件：可采用假脱机技术。</li>\n<li>破坏部分分配：可采用一次性满足请求，即静态预先分配。</li>\n<li>破坏不剥夺性：可采用可剥夺方法。</li>\n<li>破坏环路条件：可采用检测是否可能出现死锁，再决定是  否进行分配。</li>\n</ul>\n<p>策略：</p>\n<ul>\n<li>采用<strong>资源静态分配</strong>方式预防死锁</li>\n<li>采用资源动态分配、有控分配方法来避免死锁</li>\n<li>当死锁发生时检测出死锁，并设法修复。</li>\n<li>忽略死锁，认为死锁不会发生。</li>\n</ul>\n<p><strong>死锁的避免</strong></p>\n<p>银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。<br>该算法存在的缺陷：花费的<strong>开销大</strong>。</p>\n<p><strong>资源的静态分配</strong>：资源静态分配策略要求每个过程在开始执行前申请所需的全部资源, 仅在系统为之分配了所需的全部资源后,该进程才开始执行。（就是一开始直接分配全部资源）（破坏了占有并等待）</p>\n<h1 id=\"Chp6-处理机调度\"><a href=\"#Chp6-处理机调度\" class=\"headerlink\" title=\"Chp6 处理机调度\"></a>Chp6 处理机调度</h1><h2 id=\"处理机的多级调度\"><a href=\"#处理机的多级调度\" class=\"headerlink\" title=\"处理机的多级调度\"></a>处理机的多级调度</h2><p><strong>处理机调度的功能</strong></p>\n<ul>\n<li>确定数据结构</li>\n<li>制订调度策略 (调度原则) </li>\n<li>给出调度算法</li>\n<li>具体的实施处理机分派</li>\n</ul>\n<p><strong>批处理系统中的处理机调度</strong></p>\n<p>处理机调度分为两级：作业调度和进程调度。<br><strong>作业调度</strong>：作业调度又称为宏观调度。对存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。（将程序放到内存）<br><strong>进程调度</strong>：进程调度又称为微观调度。对进入主存的所有进程，确定哪个进程在什么时候获得处理机，使用多长时间。（将内存里面的程序放到CPU）</p>\n<h2 id=\"作业调度\"><a href=\"#作业调度\" class=\"headerlink\" title=\"作业调度\"></a>作业调度</h2><p><strong>作业的状态</strong></p>\n<ul>\n<li>提交状态：用户将自己的程序和数据提交给系统，等待输入。</li>\n<li>后备状态：作业已存放在磁盘上，等待调度。</li>\n<li>执行状态：作业进入主存开始运行。 </li>\n<li>完成状态：作业计算完成开始，退出系统。</li>\n</ul>\n<p><strong>作业调度的功能</strong></p>\n<p><strong>确定数据结构</strong></p>\n<ol>\n<li>建立作业控制块jcb (job control block)：作业控制块记录了每个作业类型、状态、资源请求及分配情况 。 </li>\n<li>确定调度策略与调度算法</li>\n<li>分配资源：为选中的作业分配所需要的系统资源。 </li>\n<li>善后处理：收回该作业所占用的全部资源，撤消作业控制块以及与该作业有关的全部进程。    </li>\n</ol>\n<p><strong>调度算法性能的衡量</strong></p>\n<ul>\n<li>作业周转时间=完成时间-进入系统的时间</li>\n<li>作业平均周转时间</li>\n<li>带权周转时间=作业周转时间/作业执行时间</li>\n<li>平均带权周转时间</li>\n</ul>\n<p><strong>作业调度算法</strong></p>\n<ul>\n<li><p>先来先服务</p>\n</li>\n<li><p>短作业优先（执行时间短的）</p>\n</li>\n<li><p><strong>响应比高者优先调度算法</strong>：<br>响应比=响应时间/执行事件<br>响应比=1+作业等待时间/执行时间</p>\n</li>\n<li><p>优先调度算法（对优先级高的作业先调度）</p>\n</li>\n</ul>\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p><strong>调度/分派结构</strong></p>\n<ol>\n<li>调度：在众多处于就绪状态的进程中，按一定的原则选择一个进程。</li>\n<li>分派：当处理机空闲时，是移出就绪队列中第一个进程，并赋予它使用处理机的权利</li>\n</ol>\n<p><strong>进程调度方式</strong></p>\n<ul>\n<li>非剥夺方式</li>\n<li>剥夺方式</li>\n</ul>\n<p><strong>进程调度算法</strong></p>\n<ul>\n<li>进程优先数调度算法<br>以静态方式指派给进程称为<strong>静态优先数</strong>，它一般在进程被创建是确定<br><strong>动态优先数</strong>是指在动态的过程中修改进程的优先级。例如，进程优先数随着它占用CPU时间的延长而下降；进程进行I/O操作时，提高优先数。</li>\n<li>循环轮转调度</li>\n<li>多级反馈队列调度</li>\n</ul>\n<p><strong>进程状态变迁图</strong></p>\n<img src=\"/post/操作系统期末复习/image-20220101161341589.png\" alt=\"image-20220101161341589\" style=\"zoom:50%;\" />\n\n<h1 id=\"Chp7-主存管理\"><a href=\"#Chp7-主存管理\" class=\"headerlink\" title=\"Chp7 主存管理\"></a>Chp7 主存管理</h1><p><strong>物理地址</strong>：是计算机主存单元的真实地址，又称为绝对地址或实地址。物理地址的集合所对应的空间组成了<strong>主存空间</strong>。而主存的一个<strong>区域</strong>是物理地址集合的一个递增整数序列子集所对应的主存空间。</p>\n<p>逻辑地址：用户的程序地址（指令地址或操作数地址）均为逻辑地址。用户程序的所有的逻辑地址集合对应的空间称为<strong>作业地址空间</strong></p>\n<p><strong>主存所需要管理的功能</strong></p>\n<ul>\n<li>实现逻辑地址到物理主存地址的映射</li>\n<li>主存分配</li>\n<li>存储保护</li>\n<li>主存扩充</li>\n</ul>\n<p><strong>主存映射</strong></p>\n<ul>\n<li>地址映射：将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程，称为地址映射</li>\n<li>地址映射方式：<ol>\n<li>编程或编译时确定地址映射关系</li>\n<li>在作业装入时确定地址映射关系—-静态地址映射</li>\n<li>在程序运行时确定地址映射关系 —-动态地址映射</li>\n</ol>\n</li>\n</ul>\n<p><strong>主存分配</strong></p>\n<ul>\n<li>指定分配策略：主存分配策略、放置策略、调入策略、淘汰策略</li>\n</ul>\n<p><strong>存储保护</strong></p>\n<p>程序只能在给定的存储区域内活动。两种方式防止：上下界防护、基址限长寄存器的办法。</p>\n<h2 id=\"分区存储管理\"><a href=\"#分区存储管理\" class=\"headerlink\" title=\"分区存储管理\"></a>分区存储管理</h2><p><strong>分区分配机构</strong></p>\n<ul>\n<li><p>主存资源信息块</p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th>等待队列指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>空闲区队列指针</td>\n</tr>\n<tr>\n<td>主存分配程序入口地址</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>分区描述器</p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th>分配标志（是否被使用）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>分区大小</td>\n</tr>\n<tr>\n<td>勾链字（对空闲分区而言，为空闲区队列中的勾链字，指向队列中下一个空弦分区，对已分配区而言，此项为零）</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p><strong>分区的分配与回收</strong></p>\n<ul>\n<li>分配</li>\n<li>回收：四种情况，上邻空闲区、下邻空闲区、上下邻空闲区、上下邻已分配区。</li>\n</ul>\n<img src=\"/posts/操作系统期末复习/image-20220101165628326.png\" alt=\"image-20220101165628326\" style=\"zoom:80%;\" />\n\n<p><strong>放置策略</strong></p>\n<ul>\n<li>首次适应算法：按照<strong>地址从小到大</strong>进行放置</li>\n<li>最佳适应算法：按照<strong>空闲空间从小到大</strong>进行放置</li>\n<li>最坏适应算法：按照<strong>空闲空间从大到小</strong>进行放置</li>\n</ul>\n<h2 id=\"页式存储管理\"><a href=\"#页式存储管理\" class=\"headerlink\" title=\"页式存储管理\"></a>页式存储管理</h2><p><strong>页</strong>：程序的地址空间被等分成大小相等的片，称为页面，又称为虚页，等于内存上的<strong>块</strong></p>\n<p><strong>主存块</strong>：主存被等分成大小相等的片，称为主存块，又称为实页</p>\n<p><strong>页表</strong>：为了实现从地址空间到物理主存的映象，系统建立的记录页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表。</p>\n<p><strong>为什么要分页</strong></p>\n<p>主要解决的问题就是防止产生更多的分区碎片。</p>\n<p><strong>页式系统需解决那些问题？</strong></p>\n<ul>\n<li>页式系统的地址映射</li>\n<li>请调策略</li>\n<li>放置策略</li>\n<li>淘汰策略</li>\n</ul>\n<p><strong>内碎片与外碎片</strong></p>\n<p>内碎片：是处于 <strong>（操作系统分配的用于装载某一进程的内存）区域内部</strong> 的存储块</p>\n<p>外碎片：指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p>\n<h2 id=\"页式地址变换\"><a href=\"#页式地址变换\" class=\"headerlink\" title=\"页式地址变换\"></a>页式地址变换</h2><img src=\"/post/操作系统期末复习/image-20220102100512566.png\" alt=\"image-20220102100512566\" style=\"zoom:80%;\" />\n\n<h2 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h2><p><strong>颠簸</strong>：导致系统效率急剧下降的主存和辅存之间的频繁页面置换现象称为颠簸</p>\n<p><strong>置换算法</strong></p>\n<ul>\n<li>先进先出算法（FIFO）</li>\n<li>最久未使用淘汰算法（LRU）<br>选择最长时间未被使用的那一页淘汰。<br>计数器：保存一个页存在于主存中的时间，越长代表越久未使用<br>堆栈：每当一个页面被访问过，就立即将它的页号记在页号栈的顶部，而将栈中原有的页号依次下移。这样子，栈最下面的页就是最久未访问的页。</li>\n<li>LRU近似算法：当一个页面被访问，引用位置1，淘汰则选择引用位为0的页面。当然，所有页的引用位会周期性的至0，这样子保证能够有页调出去。</li>\n<li>LFU算法：最不经常使用淘汰算法。</li>\n</ul>\n<h2 id=\"段页式存储管理\"><a href=\"#段页式存储管理\" class=\"headerlink\" title=\"段页式存储管理\"></a>段页式存储管理</h2><p><strong>段号+段内页号+页内位移</strong></p>\n<p>段式系统，它是一个连续的地址空间。分段是一个有意义的信息单位（比如，代码段，数据段，栈段）</p>\n<h1 id=\"Chp8-输入-输出管理\"><a href=\"#Chp8-输入-输出管理\" class=\"headerlink\" title=\"Chp8 输入/输出管理\"></a>Chp8 输入/输出管理</h1><p><strong>什么是设备独立性？</strong></p>\n<p>所谓设备独立性是指，用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。</p>\n<p><strong>逻辑设备名</strong>：逻辑设备名，是用户自己指定的设备名(或设备号)，它是暂时的、可更改的。</p>\n<p><strong>物理设备名</strong>：物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。</p>\n<p><strong>如何实现设备独立性</strong>：为了实现设备的独立性，应引入<strong>逻辑设备</strong>和<strong>物理设备</strong>两个概念。在<strong>应用程序</strong>（用户程序）中，使用逻辑设备名称来请求使用某类设备；而系统执行时，是使用物理设备名称。鉴于驱动程序是一个与硬件（或设备）紧密相关的软件，必须在驱动程序之上设置一层软件，称为设备独立性软件，以执行所有设备的公有操作、完成<strong>逻辑设备名到物理设备名的转换</strong>（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。</p>\n<h2 id=\"缓冲技术\"><a href=\"#缓冲技术\" class=\"headerlink\" title=\"缓冲技术\"></a>缓冲技术</h2><p><strong>主要解决问题</strong>：解決速度不匹配的问题</p>\n<p><strong>缓冲</strong>：缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段</p>\n<p><strong>缓冲器</strong>：容量较小，是用来暂时存放数据的一种存储装置</p>\n<p><strong>缓冲区</strong>：用来保存在两设备之间或在设备和应用程序之间所传数据的内存区域</p>\n<p><strong>使用缓冲的理由</strong>：</p>\n<ul>\n<li>缓和CPU与I/O设备速度不匹配的矛盾</li>\n<li>提高它们之间的并行性</li>\n<li>减少对CPU的中断次数，放宽CPU对中断响应时间的要求</li>\n</ul>\n<h2 id=\"设备分配\"><a href=\"#设备分配\" class=\"headerlink\" title=\"设备分配\"></a>设备分配</h2><p><strong>独享设备</strong>是指让一个作业在整个运行期间独占使用的设备。<strong>独享分配</strong>：在一个作业执行前，将它所要使用的设备分配给它；当它结束撤离时，将分配给它的这类设备收回。</p>\n<p><strong>共享设备</strong>：由多个作业、进程共同使用的设备称为共享设备。<strong>共享分配</strong>：共享分配就是动态分配。当进程提出资源申请时，由设备管理模块进行分配，进程使用完毕后，立即归还。</p>\n<p><strong>什么是虚拟技术？</strong></p>\n<p>所谓虚拟技术，是在一类物理设备上模拟另一类物理设备的技术，是将独占设备转化为共享设备的技术</p>\n<p><strong>什么是虚拟设备？</strong></p>\n<p>通常把用来代替独占型设备的那部分外存空间(包括有关的控制表格)称为虚拟设备。</p>\n<p><strong>什么是虚拟分配？</strong></p>\n<p>当进程需要与独占型设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为设备的虚拟分配</p>\n<h2 id=\"Spooling系统\"><a href=\"#Spooling系统\" class=\"headerlink\" title=\"Spooling系统\"></a>Spooling系统</h2><p><strong>预输入</strong>：在作业需要数据前，操作系统已将所需数据预先输入到辅存输入井存放。当作业（或进程）需要数据时，可以从辅存中读入内存</p>\n<p><strong>缓输出</strong>：在作业执行时，将输出数据写入辅存输出井中。当作业（或进程）执行完毕（或需要数据时），由操作系统将数据输出</p>\n<p><strong>什么是SPOILING系统</strong></p>\n<p>利用通道、中断技术，在主机控制之下，由通道完成输入输出工作。系统提供一个软件系统(包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行称赞。这一软件系统称为SPOOLING系统 。</p>\n<h2 id=\"输入输出控制\"><a href=\"#输入输出控制\" class=\"headerlink\" title=\"输入输出控制\"></a>输入输出控制</h2><p>通道的分类：</p>\n<ul>\n<li>字节多路通道主要用来连接大量低速设备</li>\n<li>选择通道，常用它来连接单台高速外部设备</li>\n<li>数组多路通道，一般连接中速设备，如磁带机。</li>\n</ul>\n<p>通道的意义：不同的通道是为了支持不同速率的设备</p>\n<h1 id=\"Chp9-文件系统\"><a href=\"#Chp9-文件系统\" class=\"headerlink\" title=\"Chp9 文件系统\"></a>Chp9 文件系统</h1><p>文件系统的功能：文件系统是对<strong>文件存储设备的空间</strong>进行<strong>组织</strong>和<strong>分配</strong>，负责文件存储并对存入的文件进行<strong>保护</strong>和<strong>检索</strong>的系统</p>\n<p>文件系统：文件系统是操作系统中<strong>负责管理和存取文件信息</strong>的软件机构，它由管理文件所需的数据结构、相应的管理软件，以及访问文件的一组操作组成。</p>\n<p>文件逻辑结构：流式文件、记录式文件。</p>\n<p>文件物理结构：连续文件、串联文件、随机文件、索引文件。</p>\n<p>什么是文件目录：是一张记录所有文件名字以及其存放地址的目录表。表中还应包括关于文件的说明和控制方面信息。</p>\n<h1 id=\"基本计算题型分析\"><a href=\"#基本计算题型分析\" class=\"headerlink\" title=\"基本计算题型分析\"></a>基本计算题型分析</h1><h2 id=\"P-V信号灯\"><a href=\"#P-V信号灯\" class=\"headerlink\" title=\"P,V信号灯\"></a>P,V信号灯</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有一个仓库，可以存放A,B两种产品，但要求：<br>(1)   每次只能存入一种产品（A或B）；<br>(2)    -N&lt;A产品数量-B产品数量&lt;M<br>*其中，N和 M是正整数。使用P、V操作描述产品A和产品B的入库过程。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Int  mutex&#x3D;1 ;  &#x2F;*互斥信号量*&#x2F;\nInt  sa&#x3D;M-1-(pa-pb);&#x2F;&#x2F;代表pa-pb距离M的差距    &#x2F;*pa,pb为产品A,B的库存数量*&#x2F;\nInt  sb&#x3D;N-1-(pb-pa);&#x2F;&#x2F;代表pa-pb距离N的差距\nMain()\n&#123;  \n    cobegin;\n    inputA();\n    inputB();\n    coend;\n&#125;\ninputA();\n&#123;\n    While(true)\n    &#123;\n        P(sa);\n        P(mutex);\n        产品A入库;\n        V(mutex);\n        V(sb);\n    &#125;\n&#125;\n\ninputB();\n&#123;\n    P(sb);\n    P(mutex);\n    产品B入库;\n    V(mutex);\n    V(sa);\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>讨论使用信号量和P、V 操作解决操作系统经典的五个哲学家吃通心面问题（Dijkstra，1965）。<br>有五个哲学家围坐在一圆桌旁，桌子中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后，欲吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main()\n&#123;\n    int fork[0...4]&#x3D;&#123;1,1,1,1,1,1&#125;;&#x2F;&#x2F;代表叉子的使用情况\n    cobegin\n        p1;p2;p3;p4;p5;\n    coend\n&#125;\n\nprocess Pi   &#x2F;*i&#x3D;0,1,2,3,4 *&#x2F;\n&#123;\n    while()\n    &#123;\n        思考;\n        P(fork[i]);\n        P(fork[i+1] mod 5);\n        吃通心面;\n        V(fork[i]);\n        V(fork[i+1] mod 5);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>总结</strong>：</p>\n<ul>\n<li>是否存在互斥变量（如果有多个人对同一个物体进行操作时，很显然需要判断是否有互斥）</li>\n<li>存在哪些主体（操作的哪些人）</li>\n<li>被操作物体的数量</li>\n</ul>\n<h2 id=\"资源分配问题-死锁\"><a href=\"#资源分配问题-死锁\" class=\"headerlink\" title=\"资源分配问题+死锁\"></a>资源分配问题+死锁</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>某系统有R1,R2,R3共三种资源，在T0时刻P1,P2,P3,P4这4个进程对资源的占用和需求情况如表所示，此时系统的可用资源向量为（2，1，2）。试问：<br>（1）将系统中各种资源总数和此刻各进程对各种资源的需求数量用向量或矩阵表示出来。<br>（2）如果此时P1,P2均发出资源请求向量request(1,0,1),为了保证系统的安全性，应该如何分配资源给这两个进程？说明你采用策略的原因。<br>（3）如果（2）中两个请求立即得到满足后，系统此刻是否处于死锁状态？</p></blockquote>\n<p><strong>解答</strong>:</p>\n<ol>\n<li>对于第一题，直接画个矩阵即可</li>\n<li>按需分配判断，查看剩下的系统资源是否可以满足某个进程的<strong>资源请求</strong>并<strong>释放</strong></li>\n<li>若同时分配给P1、P2进程资源(1,0,1)，则系统剩余资源(0,1,0) 此刻系统并<strong>没有立即进入死锁状态</strong>，因为这时所有进程<strong>没有提出新的资源申请</strong>，全部进程均没有因资源请求没得到满足而进入阻塞状态。只有当进程提出资源申请且全部进程都进入阻塞状态时，系统才处于死锁状态。</li>\n</ol>\n<h2 id=\"作业调度-计算时间相关\"><a href=\"#作业调度-计算时间相关\" class=\"headerlink\" title=\"作业调度+计算时间相关\"></a>作业调度+计算时间相关</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>多道程序系统中，供用户使用的内存空间有100KB，磁带机2台，打印机1台。系统采用可变式分区分配方式管理内存，对磁带机和打印机采用静态分配方式，并假设输入/输出操作的时间忽略不计。现有一作业序列如下：</p>\n<table>\n<thead>\n<tr>\n<th>作业号</th>\n<th>到达时间</th>\n<th>要求计算时间</th>\n<th>要求内存量</th>\n<th>申请磁带机数</th>\n<th>申请打印机数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>8：00</td>\n<td>25分</td>\n<td>15K</td>\n<td>1台</td>\n<td>1台</td>\n</tr>\n<tr>\n<td>2</td>\n<td>8：20</td>\n<td>10分</td>\n<td>30K</td>\n<td>—</td>\n<td>1台</td>\n</tr>\n<tr>\n<td>3</td>\n<td>8：20</td>\n<td>20分</td>\n<td>60K</td>\n<td>1台</td>\n<td>—</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8：30</td>\n<td>20分</td>\n<td>20K</td>\n<td>1台</td>\n<td>—</td>\n</tr>\n<tr>\n<td>5</td>\n<td>8：35</td>\n<td>15分</td>\n<td>10K</td>\n<td>1台</td>\n<td>1台</td>\n</tr>\n</tbody></table>\n<p>假设作业调度采用FCFS算法，优先分配内存的低地址区域且不准移动已在内存中的作业，在内存中的作业平分CPU时间，试问：<br>（1）    作业调度的次序是什么？<br>（2）    全部作业运行结束的时刻是什么？<br>（3）    写出所有作业的周转时间及最大的作业周转时间。<br>（4）    平均周转时间是多少？ </p></blockquote>\n<p><strong>解答</strong>:</p>\n<ul>\n<li><strong>明确</strong>：<strong>FCFS</strong>叫做”先来先服务“算法。作业在CPU中平分时间，意思就是分时间片，比如A,B在CPU内运行10分钟，相当于A运行了5分钟，B运行了5分钟。优先分配内存的<strong>低地址区域</strong>（这个与内存调度策略有关了）。</li>\n</ul>\n<h2 id=\"内存页调度问题-计算缺页率\"><a href=\"#内存页调度问题-计算缺页率\" class=\"headerlink\" title=\"内存页调度问题+计算缺页率\"></a>内存页调度问题+计算缺页率</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>已知页面走向为1，2，1，3，1，2，4，2，1，3，4，且开始执行时内存中没有页面。若只给该作业分配2个物理块，当采用FIFO页面淘汰算法时缺页率为多少？假定现有一种淘汰算法，该算法淘汰页面的策略为当需要淘汰页面时，就把刚使用过的页面作为淘汰对象，试问就相同的也面走向，其缺页率又为多少？</p></blockquote>\n<p><strong>解答</strong>:</p>\n<ul>\n<li><strong>明确</strong>：采用的哪种<strong>调度算法</strong>，<strong>物理块</strong>有多大</li>\n<li><strong>思路</strong>：绘制表格仔细填写即可</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>绘制页式转换图</p></blockquote>\n<img src=\"/post/操作系统期末复习/image-20220102100512566.png\" alt=\"image-20220102100512566\" style=\"zoom:80%;\" />\n\n<h2 id=\"根据页式or段页式求物理地址\"><a href=\"#根据页式or段页式求物理地址\" class=\"headerlink\" title=\"根据页式or段页式求物理地址\"></a>根据页式or段页式求物理地址</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在一个分段存储管理系统中，其段表如表1所示，试求出表2中逻辑地址对应的物理地址。</p>\n<p>表1</p>\n<table>\n<thead>\n<tr>\n<th>段号</th>\n<th>内存起始地址</th>\n<th>段长</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>210</td>\n<td>500</td>\n</tr>\n<tr>\n<td>1</td>\n<td>2350</td>\n<td>20</td>\n</tr>\n<tr>\n<td>2</td>\n<td>100</td>\n<td>90</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1350</td>\n<td>590</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1938</td>\n<td>95</td>\n</tr>\n</tbody></table>\n<p>表2</p>\n<table>\n<thead>\n<tr>\n<th>段号</th>\n<th>段内位移</th>\n<th>物理地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>430</td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>10</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>500</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>400</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>112</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>32</td>\n<td></td>\n</tr>\n</tbody></table></blockquote>\n<p><strong>解答</strong>:</p>\n<ul>\n<li><strong>明确</strong>：是否为<strong>非法地址</strong>，是否<strong>主存越界</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>某操作系统采用页式存储管理模式，若该系统允许用户编程空间为32个页面（每页1KB），主存为16KB。如果有一个用户有10页长。某时刻该用户程序页表如下图所示（仅显示已调入内存的页）。若程序遇到以下三个逻辑地址：0AC5H、1AC5H、3AC5H处的操作，试将其分别转化为物理地址，并分析存储管理系统将如何操作。</p>\n<table>\n<thead>\n<tr>\n<th>逻辑页号</th>\n<th>物理块号</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>8</td>\n</tr>\n<tr>\n<td>1</td>\n<td>7</td>\n</tr>\n<tr>\n<td>2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3</td>\n<td>10</td>\n</tr>\n</tbody></table></blockquote>\n<p><strong>注意</strong>：缺页中断、越界中断</p>\n<p><strong>技巧</strong>：将16进制转换为2进制进行除法。</p>\n<h2 id=\"CPU利用率\"><a href=\"#CPU利用率\" class=\"headerlink\" title=\"CPU利用率\"></a>CPU利用率</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>设有两个处理机P1，P2，它们各有一个硬件高速缓冲存储器C1，C2，且各有一个主存储器M1，M2，其性能如表所示。假定两个处理机的指令系统相同，它们的指令执行时间与存储器的平均存取周期成正比。如果执行某个程序时，所需的指令或数据在缓冲区中存取到的概率P是0.7，试问这两个处理机速度哪个快？当P=0.9时，处理机的处理速度哪个快？</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>C1</th>\n<th>C2</th>\n<th>M1</th>\n<th>M2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储容量</td>\n<td>4KB</td>\n<td>4KB</td>\n<td>2MB</td>\n<td>2MB</td>\n</tr>\n<tr>\n<td>存取周期</td>\n<td>60ns</td>\n<td>80ns</td>\n<td>1us</td>\n<td>0.9us</td>\n</tr>\n</tbody></table></blockquote>\n<p><strong>解答</strong>：</p>\n<ul>\n<li><strong>明确</strong>：平均存取周期：<br>$$<br>T=T_CP+T_M(1-P)<br>$$<br>其中c与m分别是高速缓冲区，与主存区的存储周期。还有，根据题目意思得，取的指令或数据有两个来源，一个是<strong>高速缓冲区</strong>，一个是<strong>主存区</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>假设就绪队列中有10个进程，系统将时间片设为200ms,CPU进行进程切换要花费10 ms，试问系统开销所占的比率约为多少？</p></blockquote>\n<p><strong>解答</strong>：</p>\n<ul>\n<li>系统开销所占的比率=10/(10+200)=4.8%</li>\n</ul>\n<h2 id=\"文件-目录-大小\"><a href=\"#文件-目录-大小\" class=\"headerlink\" title=\"文件+目录+大小\"></a>文件+目录+大小</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>某文件系统空间的最大容量为4TB（1T=240），以磁盘块为基本分配单位，磁盘块大小为1KB。文件控制块（FCB）包含一个512B的索引表区。请回答下列问题：</p>\n<ol>\n<li>假设索引表区仅采用直接索引结构，索引表区存放文件占用的磁盘块号。索引表项中块号最少占多少字节？可支持的单个文件最大长度是多少字节？</li>\n<li>假设索引表区采用如下结构：第0~7字节采用 &lt;起始块号，块数&gt; 格式表示文件创建时预分配的连续存储空间，其中起始块号占6B，块数占2B；剩余504字节采用直接索引结构，一个索引项占6B，则可支持的单个文件最大长度是多少字节？为了使单个文件的长度达到最大，请指出起始块号和块数分别所占字节数的合理值并说明理由。</li>\n</ol></blockquote>\n<ol>\n<li><p>该文件系统空间总的盘块数为4TB/1KB=4G=232个，因此索引表项中块号最少占32/8=4字节。由于索引表区可存放的盘块号最多为512B/4B=128个，因此可支持的单个文件最大长度是128*1KB=128KB。</p>\n</li>\n<li><p>由于&lt;起始块号，块数&gt; 格式中，块数占2B，因此为文件预分配的连续存储空间最大为2161KB=64MB。直接索引结构部分支持的文件最大长度为（504B/6B）1KB=84KB。综上该地址结构可支持的单个文件最大长度是64MB+84KB=65620KB。</p>\n<p>起始块号和块数分别所占字节数的合理值是 &lt;4, 4&gt; ，块号占4B正好可以表示232个盘块，块数占4B支持的文件最大长度是232*1KB=4TB，正好可以达到文件系统空间的最大容量。</p>\n</li>\n</ol>\n<h1 id=\"理论题汇总板块\"><a href=\"#理论题汇总板块\" class=\"headerlink\" title=\"理论题汇总板块\"></a>理论题汇总板块</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>处理机的管态转变为目态（用户态）是通过设置程序状态字来实现的</p></blockquote>\n<p>对！</p>\n<p>关键词：管态、目态、程序状态字</p>\n<p>程序状态字：表明系统运行状态的部件是<strong>程序状态字</strong>，程序状态字PSW（Program Status Word）包括的状态位有<strong>进位标志位（CF）</strong>、<strong>结果为零标志位（ZF）</strong>、<strong>符号标志位（SF）</strong>、<strong>溢出标志位（OF）</strong>、<strong>陷阱标志位（TF）</strong>、<strong>中断使能（中断屏蔽）标志位（IF）</strong>、<strong>虚拟中断标志位（VIF）</strong>、<strong>虚拟中断待决标志位（VIP）</strong>、<strong>I0特权级别（IOPL）</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所谓并发是指两个或两个以上进程在同一时刻执行</p></blockquote>\n<p>错！只要有一小段的时间重合，也可以称之为并发</p>\n<p><strong>关键词</strong>：什么是并发</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>进程之间存在哪几种相互制约关系？各是由什么原因引起的？</p></blockquote>\n<p>直接制约关系（同步）、间接制约关系（互斥）。间接制约关系式是存在资源的竞争，直接制约关系是存在资源的共享</p>\n<p><strong>关键词</strong>：相互制约关系</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>试论述进程与线程在资源拥有和开销的区别</p></blockquote>\n<p>什么是进程：进程可以认为是程序执行的一个实例，<strong>进程是系统进行资源分配的最小单位</strong>。</p>\n<p>什么是线程：线程又被称为轻量级的进程，线程是操作系统可识别的最小执行和调度单位。</p>\n<p>进程在资源上的拥有：地址空间、堆、全局变量、栈、寄存器。线程在资源上的拥有：线程栈，寄存器，程序计数器。</p>\n<p>进程的开销大（主要的原因是进程存在页调度），线程的开销小。</p>\n<p><strong>关键词</strong>：线程、进程</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>分页存储管理需要解决什么问题？试叙述其基本原理。</p></blockquote>\n<p>（1）需要解决地址映射问题、调度策略、淘汰策略、放置策略。（2）分页存储管理的基本原理是，将程序分成若干个大小相等的页，主存空间分成若干个大小相等的块，然后将页面放到主存块中。</p>\n<p>关键词：分页存储</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>解决死锁问题有哪几种策略？他们处理死锁的基本思想是什么？</p></blockquote>\n<p>（1）预防，采用静态资源分配的方法预防死锁。（2）避免，采用资源动态分类、有控分配方法来避免。（3）检测，当死锁发生时检测出死锁。（4）忽略，认为死锁不会发生。</p>\n<p><strong>关键词</strong>：死锁、策略</p>\n<p><strong>附加</strong>：死锁产生的四个必要条件。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>何为虚拟设备？请说明Spolling系统是如何实现虚拟设备的。</p></blockquote>\n<p>（1）通常把用来<strong>代替独占型设备</strong>的那部分外存空间(包括有关的控制表格)称为虚拟设备。（1）当某进程需要独占型设备交换信息时。Spool系统就将与该独占设备所对应的那部分磁盘、磁鼓的一部分存储控件分配给他。</p>\n<p><strong>关键词</strong>：虚拟设备，Spool</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>什么是临界资源？什么是临界区？</p></blockquote>\n<p>（1）是指只允许一个进程使用的资源叫做临界资源。（2）对于每个进程来说，访问临界资源的那段代码称为临界资源。</p>\n<p><strong>关键词</strong>：临界资源、临界区</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>进程最根本的特性是动态性和独立性</p></blockquote>\n<p>错！进程最根本的特性是并发性与动态性。</p>\n<p><strong>关键词</strong>：进程</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>存储管理系统负责管理计算机中所有内、外存空间的分配与管理。</p></blockquote>\n<p>错！存储管理系统负责计算机内存，文件管理系统负责计算机外存空间</p>\n<p>关键词：内存，存储管理系统</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>现代操作系统为什么普遍采用多道程序设计技术，其特点是什么？</p></blockquote>\n<p>多道程序设计是指在主存中同时存放多道用户作业,它们都处于执行的开始点和结束点之间。多道程序设计的特点如下:</p>\n<p>(1)多道。主存中有多道程序,它们在任一时刻必须处于就绪、运行、阻塞三种状态之一。</p>\n<p>(2)宏观上并行。从宏观上看,它们在同时执行。</p>\n<p>(3)微观上串行。从微观上看,它们在交替、穿插地执行。</p>\n<p>采用多道程序设计后,减少了CPU时间的浪费。尤其对计算题的作业,由于I/O操作较少,CPIJ浪费的时间很少。</p>\n<p><strong>关键词</strong>：现代操作系统、多道程序技术</p>\n","text":"题型我不知道 Chp1 绪论操作系统的特性：并发、共享、虚拟、异步。 Chp2 操作系统的组织结构操作系统虚拟机什么是操作系统虚拟机？ 在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。 处理机的状态设置处理机状态的...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"学习","slug":"学习","count":3,"path":"api/categories/学习.json"}],"tags":[{"name":"学习","slug":"学习","count":4,"path":"api/tags/学习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">题型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp1-%E7%BB%AA%E8%AE%BA\"><span class=\"toc-text\">Chp1 绪论</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Chp2 操作系统的组织结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">操作系统虚拟机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">处理机的状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">中断技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">向量中断</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp3-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">Chp3 用户界面</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">系统功能调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp4-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Chp4 并发处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">进程概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">进程控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">进程的相互制约关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">同步机构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程通信</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp5-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">Chp5 资源分配与调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">资源分配机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">资源分配策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp6-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">Chp6 处理机调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E5%A4%9A%E7%BA%A7%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">处理机的多级调度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">作业调度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">进程调度</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp7-%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">Chp7 主存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">分区存储管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">页式存储管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">页式地址变换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">淘汰策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">段页式存储管理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp8-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">Chp8 输入&#x2F;输出管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">缓冲技术</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D\"><span class=\"toc-text\">设备分配</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spooling%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">Spooling系统</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">输入输出控制</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">Chp9 文件系统</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E9%A2%98%E5%9E%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">基本计算题型分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#P-V%E4%BF%A1%E5%8F%B7%E7%81%AF\"><span class=\"toc-text\">P,V信号灯</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98-%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">资源分配问题+死锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">作业调度+计算时间相关</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E9%A1%B5%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98-%E8%AE%A1%E7%AE%97%E7%BC%BA%E9%A1%B5%E7%8E%87\"><span class=\"toc-text\">内存页调度问题+计算缺页率</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%8D%AE%E9%A1%B5%E5%BC%8For%E6%AE%B5%E9%A1%B5%E5%BC%8F%E6%B1%82%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">根据页式or段页式求物理地址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CPU%E5%88%A9%E7%94%A8%E7%8E%87\"><span class=\"toc-text\">CPU利用率</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">文件+目录+大小</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%AE%BA%E9%A2%98%E6%B1%87%E6%80%BB%E6%9D%BF%E5%9D%97\"><span class=\"toc-text\">理论题汇总板块</span></a></li></ol>","author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"2021年度总结","uid":"10e799bf47669bd7fff35712248e1c6e","slug":"2021年度总结","date":"2021-12-31T12:34:06.000Z","updated":"2021-12-31T15:15:35.343Z","comments":true,"path":"api/articles/2021年度总结.json","keywords":null,"cover":"/post/2021年度总结/u=3715033498,2456029672&fm=253&fmt=auto&app=120&f=JPEG.webp","text":"引言这是我第一次写年度总结在自己的博客上面，用来总结这一年到底干了什么，以及需要改进的是什么。2021年对我来说是一个过渡期，可能是让我更加明确自己方向的一个时期，但是在这方面还是拥有一点疑虑，需要再深思熟虑。 2021年做了什么？其实大致的忘了自己2021年开始到底做了什么，因...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"年度总结","slug":"年度总结","count":1,"path":"api/categories/年度总结.json"}],"tags":[{"name":"总结","slug":"总结","count":1,"path":"api/tags/总结.json"}],"author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Unity3d关键词汇总","uid":"85bcb60ef3df802e81a5da2276802e9f","slug":"Unity3d关键词汇总","date":"2021-12-28T04:01:19.000Z","updated":"2022-01-24T13:00:19.668Z","comments":true,"path":"api/articles/Unity3d关键词汇总.json","keywords":null,"cover":"/post/Unity3d关键词汇总/m001.jpg","text":"根据类型获取某个对象 &#x2F;&#x2F;这里我们找的是Canvas这个对象，该函数只找到一个 Canvas canvas &#x3D; FindObjectOfType&lt;Canvas&gt;(); 获取预制体 &#x2F;&#x2F;获取预制体 &#x2F;&#x2F...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"Unity3d","slug":"Unity3d","count":1,"path":"api/categories/Unity3d.json"}],"tags":[{"name":"Unity3d","slug":"Unity3d","count":1,"path":"api/tags/Unity3d.json"},{"name":"学习","slug":"学习","count":4,"path":"api/tags/学习.json"}],"author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}