{"title":"操作系统期末复习","uid":"9e81543b01b9fb4d973d1efdec16b262","slug":"操作系统期末复习","date":"2021-12-31T06:26:35.000Z","updated":"2022-01-04T07:11:38.451Z","comments":true,"path":"api/articles/操作系统期末复习.json","keywords":null,"cover":"/post/随思所想（一）/m007.jpg","content":"<h1 id=\"题型\"><a href=\"#题型\" class=\"headerlink\" title=\"题型\"></a>题型</h1><p>我不知道</p>\n<h1 id=\"Chp1-绪论\"><a href=\"#Chp1-绪论\" class=\"headerlink\" title=\"Chp1 绪论\"></a>Chp1 绪论</h1><p><strong>操作系统的特性</strong>：并发、共享、不确定新。</p>\n<h1 id=\"Chp2-操作系统的组织结构\"><a href=\"#Chp2-操作系统的组织结构\" class=\"headerlink\" title=\"Chp2 操作系统的组织结构\"></a>Chp2 操作系统的组织结构</h1><h2 id=\"操作系统虚拟机\"><a href=\"#操作系统虚拟机\" class=\"headerlink\" title=\"操作系统虚拟机\"></a>操作系统虚拟机</h2><p><strong>什么是操作系统虚拟机？</strong></p>\n<p>在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。</p>\n<h2 id=\"处理机的状态\"><a href=\"#处理机的状态\" class=\"headerlink\" title=\"处理机的状态\"></a>处理机的状态</h2><p><strong>设置处理机状态的目的？</strong></p>\n<p>为操作系统建立一个保护环境，采用的办法是区分处理机的工作状态。在系统中存在两类程序，一类是管理程序，另一类是用户程序。</p>\n<p><strong>什么是处理机的状态？</strong></p>\n<p>中央处理机的工作状态，当前它正在执行哪类程序，决定处理机的态。</p>\n<p><strong>管态与用户态</strong></p>\n<ul>\n<li><strong>管态</strong>：又称系统态，是<strong>操作系统</strong>管理程序执行时机器所处的状态。在此状态下允许中央处理机使用<strong>全部系统资源</strong>和全部指令（包括一组特权指令），允许访问<strong>整个存储区</strong>。</li>\n<li><strong>用户态</strong>：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">管态</th>\n<th align=\"center\">用户态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">操作系统的程序执行</td>\n<td align=\"center\">用户程序执行</td>\n</tr>\n<tr>\n<td align=\"center\">使用全部指令（包括一组特权指令）</td>\n<td align=\"center\">禁止使用特权指令</td>\n</tr>\n<tr>\n<td align=\"center\">使用全部系统资源（包括整个存储区域）</td>\n<td align=\"center\">只允许用户程序访问自己的存储区域</td>\n</tr>\n</tbody></table>\n<p><strong>特权指令</strong></p>\n<h2 id=\"中断技术\"><a href=\"#中断技术\" class=\"headerlink\" title=\"中断技术\"></a>中断技术</h2><p><strong>中断概念</strong></p>\n<p>所谓中断是指某个事件发生时，系统<strong>终止现行程序</strong>的运行、引出处理该事件程序进行处理，处理完毕后<strong>返回断点</strong>，继续执行。</p>\n<p><strong>中断类型</strong></p>\n<p>如下列举一个类型，<strong>访管中断</strong>：对操作系统提出某种需求（如请求I/O传输、建立进程等）时所发出的中断称为访管中断。</p>\n<h3 id=\"向量中断\"><a href=\"#向量中断\" class=\"headerlink\" title=\"向量中断\"></a>向量中断</h3><p><strong>什么是向量中断？</strong></p>\n<p>当中断发生时，由中断源引导处理机进入终端服务程序的中断过程称为向量中断。在向量中断中，对于每一个中断类型都设置一个中断向量。</p>\n<p><strong>中断向量</strong></p>\n<p>中断向量就是存储该类型<strong>中断的终端服务例行程序的入口地址</strong>和<strong>处理机状态字</strong>的存储单元。<br>系统中的所有中断向量放在一起，形成中断向量表。</p>\n<p><strong>向量中断处理过程</strong></p>\n<p>当发生某一中断事件时，根据该类中断的中断向量直接进入处理该事件的中断处理程序。</p>\n<h1 id=\"Chp3-用户界面\"><a href=\"#Chp3-用户界面\" class=\"headerlink\" title=\"Chp3 用户界面\"></a>Chp3 用户界面</h1><h2 id=\"系统功能调用\"><a href=\"#系统功能调用\" class=\"headerlink\" title=\"系统功能调用\"></a>系统功能调用</h2><p><strong>什么是系统功能调用？</strong></p>\n<p>白话解释：操作系统设计者编制了一些可以完成用户某些功能的例行子程序（操作系统为用户程序提供服务），这些子程序作为操作系统程序模块的一部分。用户的程序是处于用户态的，用户想要调用则需要采用一种特殊的调用方式–访管方式来实现。<strong>使用访管指令进入访管中断</strong>。</p>\n<p><strong>系统功能调用的实现</strong></p>\n<ul>\n<li>用户程序中：<code>svc n</code></li>\n<li>访管中断处理程序，保存现场</li>\n<li>例行子程序入口地址表</li>\n<li>例行子程序</li>\n<li>执行完毕后恢复现场</li>\n</ul>\n<h1 id=\"Chp4-并发处理\"><a href=\"#Chp4-并发处理\" class=\"headerlink\" title=\"Chp4 并发处理\"></a>Chp4 并发处理</h1><p><strong>顺序执行的特点</strong></p>\n<table>\n<thead>\n<tr>\n<th>特点名</th>\n<th>xxx</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>顺序性</td>\n<td>当顺序程序在处理机上执行时，处理机的操作是严格按照程序所规定的顺序执行的。</td>\n</tr>\n<tr>\n<td>封闭性</td>\n<td>程序一旦开始执行，其计算结果不受外界因素的影响。</td>\n</tr>\n<tr>\n<td>可再现性</td>\n<td>程序执行的结果与它的执行速度无关，而只与初始条件有关。</td>\n</tr>\n</tbody></table>\n<p><strong>什么是并发执行</strong></p>\n<p>若干个程序段同时在系统中运行，这些程序段在执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">cobegin;\n\tfun1(),fun2();\ncoend;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>并发执行的特点</strong></p>\n<ul>\n<li>失去程序的封闭性和再现性</li>\n<li>程序与计算不再一一对应（<strong>计算</strong>是指在处理机上的执行过程，或处理机按照程序的规定执行操作的过程，是动态的概念）</li>\n<li>程序并发执行的相互制约</li>\n</ul>\n<h2 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h2><p><strong>进程的定义</strong></p>\n<ul>\n<li>进程是程序的执行</li>\n<li>并行程序称为进程</li>\n<li>进程是可以和别的计算并发的计算</li>\n<li>进程是一个数据结构及在其上进行操作的程序</li>\n<li><strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong></li>\n</ul>\n<p><strong>进程的状态</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>info</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>就绪状态</td>\n<td>当进程获得了除CPU之外的所有资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行</td>\n</tr>\n<tr>\n<td>运行状态</td>\n<td>得到了中央处理机的控制权，它的程序正在运行</td>\n</tr>\n<tr>\n<td>等待状态</td>\n<td>若一进程正在等待某一事件发生，而暂时停止执行，这时，即使给它CPU控制权，它也无法执行</td>\n</tr>\n</tbody></table>\n<ul>\n<li>运行状态–&gt;就绪状态：CPU的时间片用完了</li>\n</ul>\n<p><strong>进程的构成</strong></p>\n<p>进程=PCB+程序+数据</p>\n<p><strong>进程的描述—进程控制块</strong></p>\n<ul>\n<li>pcb—process control block</li>\n<li>系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体</li>\n</ul>\n<p><strong>什么是线程</strong>：线程是进程中的一条执行路径</p>\n<p><strong>线程的特点</strong>：线程的创建与管理的开销要小得多。进程内可创建多线程。</p>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><p><strong>进程控制的概念</strong></p>\n<p>进程控制的职责是对系统中的全部进程实施有效的管理，它是处理机管理的一部分，当系统允许多进程并发执行是，为了实现共享、协调并发进程的关系，处理机管理机就提供对进程实行有效的功能。</p>\n<p>操作系统的核心具有<strong>创建</strong>、<strong>撤销</strong>进程和实施进程间同步、通信等功能。</p>\n<p>用于进程控制的原语有：创建原语、撤销原语、阻塞原语、唤醒原语。</p>\n<p><strong>什么是原语？</strong></p>\n<p>原语是一种特殊的系统调用，它可以完成一个特定的功能，一般为外层软件所调用，其<strong>特点</strong>是原语执行时不可中断，所欲原语操作具有<strong>原子性</strong>，即它是不在可分的。在操作系统中，原语作为一个基本单位出现的。</p>\n<p><strong>创建原语create</strong></p>\n<p><strong>撤销原语kill</strong></p>\n<p><strong>阻塞原语susp</strong></p>\n<p><strong>唤醒原语wakeup</strong></p>\n<h2 id=\"进程的相互制约关系\"><a href=\"#进程的相互制约关系\" class=\"headerlink\" title=\"进程的相互制约关系\"></a>进程的相互制约关系</h2><p>资源共享是当代计算机系统的一个重要特征。而资源共享导致进程之间存在相互制约关系。 </p>\n<p>活动的大量的并发进程有着相互制约关系。这种相互制约关系分为两种情况：一种是由于竞争系统资源而引起间接相互制约关系；另一种是由进程之间存在共享数据而引起的直接相互制约关系。</p>\n<p><strong>资源共享的方式</strong></p>\n<ol>\n<li>由系统进行统一分配</li>\n<li>由程序自行使用</li>\n</ol>\n<p><strong>进程的互斥</strong></p>\n<p>在操作系统中，当某一进程正在访问某一存储区域时，就不允许其它进程来读出或者修改存储区的内容，否则就会发生后果无法估计的错误。我们把进程之间的这种相互制约关系称为<strong>互斥</strong>。也可以说，<strong>进程的互斥是因为对同一物理资源的竞争而产生的相互制约关系</strong>。 </p>\n<p><strong>临界资源</strong>：通常把一次仅允许一个进程使用的资源称为临界资源。<br><strong>临界区</strong>：每个进程中，访问临界资源的<strong>那段程序</strong>能够从概念上分离出来，称为临界区或临界段。</p>\n<p><strong>进程的同步</strong></p>\n<p>所谓同步，就是并发进程在一些关键点上可能需要<strong>相互等待</strong>与<strong>互通消息</strong>，这种相互制约的等待与互通信息称为进程同步。</p>\n<h2 id=\"同步机构\"><a href=\"#同步机构\" class=\"headerlink\" title=\"同步机构\"></a>同步机构</h2><p><strong>信号和灯P，V操作</strong></p>\n<ul>\n<li><strong>P操作</strong>：代表资源占用，资源数量减一</li>\n<li><strong>V操作</strong>：代表释放资源，资源数量加一</li>\n</ul>\n<p><strong>用信号灯实现进程互斥</strong></p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">mian()\n&#123;\n    int mutex&#x3D;1;\t\t&#x2F;&#x2F;互斥信号灯\n    cobegin\n        p1();\n    \tp2();\n    coend\n&#125;\n\np1()\n&#123;\n    p(mutex);\n    xxx1;\n    v(mutex)\n&#125;\n\np2()\n&#123;\n    p(mutex);\n    xxx2;\n    v(mutex)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>用信号灯实现进程同步</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main()\n&#123;\n    int s1&#x3D;0; &#x2F;*表示有无化验单*&#x2F;\t\n    int s2&#x3D;0; &#x2F;*表示有无化验结果*&#x2F;\n    cobegin\n       \tlabora();\n       \tdiagnosis();\n    coend\n&#125;\n\nlabora ()\n&#123;\n     while(化验工作未完成)\n     &#123;\n        p(s1); \t\t&#x2F;*询问有无化验单，若无则等*&#x2F;\n\t\t化验工作；\n        v (s2); \t&#x2F;*送出化验结果*&#x2F;\n      &#125;\n&#125;\n\ndiagnosis ( )\n&#123;\n      while (看病工作未完成)\n      &#123;\n            看病；\n            v (s1); &#x2F;*送出化验单*&#x2F;\n            p (s2); &#x2F;*等化验结果*&#x2F;\n            diagnosis; &#x2F;*诊断*&#x2F;\n       &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>生产者–消费者问题</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main ( )\n&#123;\nint full&#x3D;0;     &#x2F;*满缓冲区的数目*&#x2F; \nint empty&#x3D;n;     &#x2F;*空缓冲区的数目*&#x2F; \nint mutex&#x3D;1;     &#x2F;*互斥作用*&#x2F;\n  \tcobegin\n        producer ( );\n    \tconsumer( );\n   \tcoend\n&#125;\n\nproducer() \n&#123;\n    while (生产未完成)\n    &#123;\n        ……;\n        生产一个产品;\n        p (empty);\n        p (mutex);\n        送一个产品到有界缓冲区中;\n        v (mutex);\n        v (full);\n    &#125;\n&#125;\nconsumer ( )\n&#123;\n    while (还要继续消费)；\n    &#123;\n        p (full);\n        p (mutex);\n        从有界缓冲区中取产品;\n        v (mutex);\n        v (empty);\n        消费一个产品;\n        ……;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><p>xxx（暂且不写）</p>\n<h1 id=\"Chp5-资源分配与调度\"><a href=\"#Chp5-资源分配与调度\" class=\"headerlink\" title=\"Chp5 资源分配与调度\"></a>Chp5 资源分配与调度</h1><p><strong>资源管理的目的</strong></p>\n<ul>\n<li>保证资源的高利用率</li>\n<li>在“合理”的时间内使所有的用户有获得资源的机会</li>\n<li>对不可共享的资源实行互斥</li>\n<li>防止由资源分配不当而引起的死锁</li>\n</ul>\n<p><strong>资源管理的任务</strong></p>\n<ul>\n<li>解决资源分配问题</li>\n<li>资源分配中防止出现死锁</li>\n<li>解决资源的存取、使用方法问题</li>\n<li>提供资源的存取的控制和实施安全保护措施</li>\n</ul>\n<h2 id=\"资源分配机制\"><a href=\"#资源分配机制\" class=\"headerlink\" title=\"资源分配机制\"></a>资源分配机制</h2><p><strong>资源描述器</strong></p>\n<p>描述各类资源的最小分配单位的数据结构称为资源描述器RD（resource descriptor）</p>\n<p><strong>信息资源块</strong></p>\n<p>rib（resource information block）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">等待队列头指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">可利用资源头指针</td>\n</tr>\n<tr>\n<td align=\"left\">资源分配程序入口地址</td>\n</tr>\n</tbody></table>\n<h2 id=\"资源分配策略\"><a href=\"#资源分配策略\" class=\"headerlink\" title=\"资源分配策略\"></a>资源分配策略</h2><p><strong>先请求先服务</strong></p>\n<p><strong>优先调度</strong></p>\n<p><strong>针对设备特性的调度</strong></p>\n<p>比如磁盘这一类硬件，那么怎么移动磁头也是一种策略。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p><strong>什么是死锁?</strong></p>\n<p>死锁是两个或多个进程无止境地等候着永远不会成立的条件的一种系统状态。</p>\n<p><strong>产生死锁的根本原因</strong></p>\n<p>是系统能够<strong>提供的资源</strong>个数比<strong>要求该资源的进程数</strong>要<strong>少</strong>。</p>\n<p><strong>产生死锁的必要条件</strong></p>\n<ul>\n<li>互斥条件。在一段时间内，一个资源只能由一个进程独占使用，若别的进程也要求该资源，则须等待直至其占用者释放。</li>\n<li>不剥夺条件。进程所获得的资源在未使用完之前，不能被其它进程强行夺走，而只能由其自行释放。</li>\n<li>占有并等待。进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。</li>\n<li>环路条件。存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。</li>\n</ul>\n<p><strong>系统模型</strong></p>\n<ul>\n<li>资源请求矩阵</li>\n<li>资源分配矩阵</li>\n</ul>\n<p><strong>解决死锁问题的策略</strong></p>\n<p>对于必要条件来说：</p>\n<ul>\n<li>破坏互斥条件：可采用假脱机技术。</li>\n<li>破坏部分分配：可采用一次性满足请求，即静态预先分配。</li>\n<li>破坏不剥夺性：可采用可剥夺方法。</li>\n<li>破坏环路条件：可采用检测是否可能出现死锁，再决定是  否进行分配。</li>\n</ul>\n<p>策略：</p>\n<ul>\n<li>采用资源静态分配方式预防死锁</li>\n<li>采用资源动态分配、有控分配方法来避免死锁</li>\n<li>当死锁发生时检测出死锁，并设法修复。</li>\n<li>忽略死锁，认为死锁不会发生。</li>\n</ul>\n<p><strong>死锁的避免</strong></p>\n<p>银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。<br>该算法存在的缺陷：花费的<strong>开销大</strong>。</p>\n<h1 id=\"Chp6-处理机调度\"><a href=\"#Chp6-处理机调度\" class=\"headerlink\" title=\"Chp6 处理机调度\"></a>Chp6 处理机调度</h1><h2 id=\"处理机的多级调度\"><a href=\"#处理机的多级调度\" class=\"headerlink\" title=\"处理机的多级调度\"></a>处理机的多级调度</h2><p><strong>处理机调度的功能</strong></p>\n<ul>\n<li>确定数据结构</li>\n<li>制订调度策略 (调度原则) </li>\n<li>给出调度算法</li>\n<li>具体的实施处理机分派</li>\n</ul>\n<p><strong>批处理系统中的处理机调度</strong></p>\n<p>处理机调度分为两级：作业调度和进程调度。<br><strong>作业调度</strong>：作业调度又称为宏观调度。对存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。（将程序放到内存）<br><strong>进程调度</strong>：进程调度又称为微观调度。对进入主存的所有进程，确定哪个进程在什么时候获得处理机，使用多长时间。（将内存里面的程序放到CPU）</p>\n<h2 id=\"作业调度\"><a href=\"#作业调度\" class=\"headerlink\" title=\"作业调度\"></a>作业调度</h2><p><strong>作业的状态</strong></p>\n<ul>\n<li>提交状态：用户将自己的程序和数据提交给系统，等待输入。</li>\n<li>后备状态：作业已存放在磁盘上，等待调度。</li>\n<li>执行状态：作业进入主存开始运行。 </li>\n<li>完成状态：作业计算完成开始，退出系统。</li>\n</ul>\n<p><strong>作业调度的功能</strong></p>\n<p><strong>确定数据结构</strong></p>\n<ol>\n<li>建立作业控制块jcb (job control block)：作业控制块记录了每个作业类型、状态、资源请求及分配情况 。 </li>\n<li>确定调度策略与调度算法</li>\n<li>分配资源：为选中的作业分配所需要的系统资源。 </li>\n<li>善后处理：收回该作业所占用的全部资源，撤消作业控制块以及与该作业有关的全部进程。    </li>\n</ol>\n<p><strong>调度算法性能的衡量</strong></p>\n<ul>\n<li>作业周转时间=完成时间-进入系统的时间</li>\n<li>作业平均周转时间</li>\n<li>带权周转时间=作业周转时间/作业执行时间</li>\n<li>平均带权周转时间</li>\n</ul>\n<p><strong>作业调度算法</strong></p>\n<ul>\n<li><p>先来先服务</p>\n</li>\n<li><p>短作业优先（执行时间短的）</p>\n</li>\n<li><p><strong>响应比高者优先调度算法</strong>：<br>响应比=响应时间/执行事件<br>响应比=1+作业等待时间/执行时间</p>\n</li>\n<li><p>优先调度算法（对优先级高的作业先调度）</p>\n</li>\n</ul>\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p><strong>调度/分派结构</strong></p>\n<ol>\n<li>调度：在众多处于就绪状态的进程中，按一定的原则选择一个进程。</li>\n<li>分派：当处理机空闲时，是移出就绪队列中第一个进程，并赋予它使用处理机的权利</li>\n</ol>\n<p><strong>进程调度方式</strong></p>\n<ul>\n<li>非剥夺方式</li>\n<li>剥夺方式</li>\n</ul>\n<p><strong>进程调度算法</strong></p>\n<ul>\n<li>进程优先数调度算法<br>以静态方式指派给进程称为<strong>静态优先数</strong>，它一般在进程被创建是确定<br><strong>动态优先数</strong>是指在动态的过程中修改进程的优先级。例如，进程优先数随着它占用CPU时间的延长而下降；进程进行I/O操作时，提高优先数。</li>\n<li>循环轮转调度</li>\n<li>多级反馈队列调度</li>\n</ul>\n<p><strong>进程状态变迁图</strong></p>\n<img src=\"/post/操作系统期末复习/image-20220101161341589.png\" alt=\"image-20220101161341589\" style=\"zoom:50%;\" />\n\n<h1 id=\"Chp7-主存管理\"><a href=\"#Chp7-主存管理\" class=\"headerlink\" title=\"Chp7 主存管理\"></a>Chp7 主存管理</h1><p><strong>物理地址</strong>：是计算机主存单元的真实地址，又称为绝对地址或实地址。物理地址的集合所对应的空间组成了<strong>主存空间</strong>。而主存的一个<strong>区域</strong>是物理地址集合的一个递增整数序列子集所对应的主存空间。</p>\n<p>逻辑地址：用户的程序地址（指令地址或操作数地址）均为逻辑地址。用户程序的所有的逻辑地址集合对应的空间称为<strong>作业地址空间</strong></p>\n<p><strong>主存所需要管理的功能</strong></p>\n<ul>\n<li>实现逻辑地址到物理主存地址的映射</li>\n<li>主存分配</li>\n<li>存储保护</li>\n<li>主存扩充</li>\n</ul>\n<p><strong>主存映射</strong></p>\n<ul>\n<li>地址映射：将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程，称为地址映射</li>\n<li>地址映射方式：<ol>\n<li>编程或编译时确定地址映射关系</li>\n<li>在作业装入时确定地址映射关系—-静态地址映射</li>\n<li>在程序运行时确定地址映射关系 —-动态地址映射</li>\n</ol>\n</li>\n</ul>\n<p><strong>主存分配</strong></p>\n<ul>\n<li>指定分配策略：主存分配策略、放置策略、掉入策略、淘汰策略</li>\n</ul>\n<p><strong>存储保护</strong></p>\n<p>不同程序只能使用自己的已分配的主存区域。两种方式防止：上下界防护、基址限长寄存器的办法。</p>\n<h2 id=\"分区存储管理\"><a href=\"#分区存储管理\" class=\"headerlink\" title=\"分区存储管理\"></a>分区存储管理</h2><p><strong>分区分配机构</strong></p>\n<ul>\n<li><p>主存资源信息块</p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th>等待队列指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>空闲区队列指针</td>\n</tr>\n<tr>\n<td>主存分配程序入口地址</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>分区描述器</p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th>分配标志（是否被使用）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>分区大小</td>\n</tr>\n<tr>\n<td>勾链字（对空闲分区而言，为空闲区队列中的勾链字，指向队列中下一个空弦分区，对已分配区而言，此项为零）</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p><strong>分区的分配与回收</strong></p>\n<ul>\n<li>分配</li>\n<li>回收：四种情况，上邻空闲区、下邻空闲区、上下邻空闲区、上下邻已分配区。</li>\n</ul>\n<img src=\"/posts/操作系统期末复习/image-20220101165628326.png\" alt=\"image-20220101165628326\" style=\"zoom:80%;\" />\n\n<p><strong>放置策略</strong></p>\n<ul>\n<li>首次适应算法：按照<strong>地址从小到大</strong>进行放置</li>\n<li>最佳适应算法：按照<strong>空闲控件从小到大</strong>进行放置</li>\n<li>最坏适应算法：按照<strong>空闲控件从大到小</strong>进行放置</li>\n</ul>\n<h2 id=\"页式存储管理\"><a href=\"#页式存储管理\" class=\"headerlink\" title=\"页式存储管理\"></a>页式存储管理</h2><p><strong>页</strong>：程序的地址空间被等分成大小相等的片，称为页面，又称为虚页，等于内存上的<strong>块</strong></p>\n<p><strong>主存块</strong>：主存被等分成大小相等的片，称为主存块，又称为实页</p>\n<p><strong>页表</strong>：为了实现从地址空间到物理主存的映象，系统建立的记录页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表。</p>\n<p><strong>为什么要分页</strong></p>\n<p>主要解决的问题就是防止产生更多的分区碎片。</p>\n<p><strong>页式系统需解决那些问题？</strong></p>\n<ul>\n<li>页式系统的地址映射</li>\n<li>请调策略</li>\n<li>放置策略</li>\n<li>淘汰策略</li>\n</ul>\n<h2 id=\"页式地址变换\"><a href=\"#页式地址变换\" class=\"headerlink\" title=\"页式地址变换\"></a>页式地址变换</h2><img src=\"/post/操作系统期末复习/image-20220102100512566.png\" alt=\"image-20220102100512566\" style=\"zoom:80%;\" />\n\n<h2 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h2><p><strong>颠簸</strong>：导致系统效率急剧下降的主存和辅存之间的频繁页面置换现象称为颠簸</p>\n<p><strong>置换算法</strong></p>\n<ul>\n<li>先进先出算法（FIFO）</li>\n<li>最久未使用淘汰算法（LRU）<br>选择最长时间未被使用的那一页淘汰。<br>计数器：保存一个页存在于主存中的时间，越长代表越久未使用<br>堆栈：每当一个页面被访问过，就立即将它的页号记在页号栈的顶部，而将栈中原有的页号依次下移。这样子，栈最下面的页就是最久未访问的页。</li>\n<li>LRU近似算法：当一个页面被访问，引用位置1，淘汰则选择引用位为0的页面。当然，所有页的引用位会周期性的至0，这样子保证能够有页调出去。</li>\n</ul>\n<h2 id=\"段页式存储管理\"><a href=\"#段页式存储管理\" class=\"headerlink\" title=\"段页式存储管理\"></a>段页式存储管理</h2><p><strong>段号+段内页号+页内位移</strong></p>\n<h1 id=\"Chp8-输入-输出管理\"><a href=\"#Chp8-输入-输出管理\" class=\"headerlink\" title=\"Chp8 输入/输出管理\"></a>Chp8 输入/输出管理</h1><p><strong>什么是设备独立性？</strong></p>\n<p>所谓设备独立性是指，用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。</p>\n<p><strong>逻辑设备名</strong>：逻辑设备名，是用户自己指定的设备名(或设备号)，它是暂时的、可更改的。</p>\n<p><strong>物理设备名</strong>：物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。</p>\n<h2 id=\"缓冲技术\"><a href=\"#缓冲技术\" class=\"headerlink\" title=\"缓冲技术\"></a>缓冲技术</h2><p><strong>主要解决问题</strong>：解決速度不匹配的问题</p>\n<p><strong>缓冲</strong>：缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段</p>\n<p><strong>缓冲器</strong>：容量较小，是用来暂时存放数据的一种存储装置</p>\n<p><strong>缓冲区</strong>：用来保存在两设备之间或在设备和应用程序之间所传数据的内存区域</p>\n<p><strong>使用缓冲的理由</strong>：</p>\n<ul>\n<li>缓和CPU与I/O设备速度不匹配的矛盾</li>\n<li>提高它们之间的并行性</li>\n<li>减少对CPU的终端次数，放宽CPU对中断响应时间的要求</li>\n</ul>\n<h2 id=\"设备分配\"><a href=\"#设备分配\" class=\"headerlink\" title=\"设备分配\"></a>设备分配</h2><p><strong>独享设备</strong>是指让一个作业在整个运行期间独占使用的设备。<strong>独享分配</strong>：在一个作业执行前，将它所要使用的设备分配给它；当它结束撤离时，将分配给它的这类设备收回。</p>\n<p><strong>共享设备</strong>：由多个作业、进程共同使用的设备称为共享设备。<strong>共享分配</strong>：共享分配就是动态分配。当进程提出资源申请时，由设备管理模块进行分配，进程使用完毕后，立即归还。</p>\n<p><strong>什么是虚拟技术？</strong></p>\n<p>所谓虚拟技术，是在一类物理设备上模拟另一类物理设备的技术，是将独占设备转化为共享设备的技术</p>\n<p><strong>什么是虚拟设备？</strong></p>\n<p>通常把用来代替独占型设备的那部分外存空间(包括有关的控制表格)称为虚拟设备。</p>\n<p><strong>什么是虚拟分配？</strong></p>\n<p>当进程需要与独占型设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为设备的虚拟分配</p>\n<h2 id=\"Spooling系统\"><a href=\"#Spooling系统\" class=\"headerlink\" title=\"Spooling系统\"></a>Spooling系统</h2><p><strong>预输入</strong>：在作业需要数据前，操作系统已将所需数据预先输入到辅存输入井存放。当作业（或进程）需要数据时，可以从辅存中读入内存</p>\n<p><strong>缓输出</strong>：在作业执行时，将输出数据写入辅存输出井中。当作业（或进程）执行完毕（或需要数据时），由操作系统将数据输出</p>\n<p><strong>什么是SPOILING系统</strong></p>\n<p>利用通道、中断技术，在主机控制之下，由通道完成输入输出工作。系统提供一个软件系统(包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行称赞。这一软件系统称为SPOOLING系统 。</p>\n<h1 id=\"Chp9-文件系统\"><a href=\"#Chp9-文件系统\" class=\"headerlink\" title=\"Chp9 文件系统\"></a>Chp9 文件系统</h1><p>按照题目来复习</p>\n<h1 id=\"基本计算题型分析\"><a href=\"#基本计算题型分析\" class=\"headerlink\" title=\"基本计算题型分析\"></a>基本计算题型分析</h1><h2 id=\"P-V信号灯\"><a href=\"#P-V信号灯\" class=\"headerlink\" title=\"P,V信号灯\"></a>P,V信号灯</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有一个仓库，可以存放A,B两种产品，但要求：<br>(1)   每次只能存入一种产品（A或B）；<br>(2)    -N&lt;A产品数量-B产品数量&lt;M<br>*其中，N和 M是正整数。使用P、V操作描述产品A和产品B的入库过程。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Int  mutex&#x3D;1 ;  &#x2F;*互斥信号量*&#x2F;\nInt  sa&#x3D;M-1-(pa-pb);&#x2F;&#x2F;代表pa-pb距离M的差距    &#x2F;*pa,pb为产品A,B的库存数量*&#x2F;\nInt  sb&#x3D;N-1-(pb-pa);&#x2F;&#x2F;代表pa-pb距离N的差距\nMain()\n&#123;  \n    cobegin;\n    inputA();\n    inputB();\n    coend;\n&#125;\ninputA();\n&#123;\n    While(true)\n    &#123;\n        P(sa);\n        P(mutex);\n        产品A入库;\n        V(mutex);\n        V(sb);\n    &#125;\n&#125;\n\ninputB();\n&#123;\n    P(sb);\n    P(mutex);\n    产品B入库;\n    V(mutex);\n    V(sa);\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>讨论使用信号量和P、V 操作解决操作系统经典的五个哲学家吃通心面问题（Dijkstra，1965）。<br>有五个哲学家围坐在一圆桌旁，桌子中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后，欲吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">main()\n&#123;\n    int fork[0...4]&#x3D;&#123;1,1,1,1,1,1&#125;;&#x2F;&#x2F;代表叉子的使用情况\n    cobegin\n        p1;p2;p3;p4;p5;\n    coend\n&#125;\n\nprocess Pi   &#x2F;*i&#x3D;0,1,2,3,4 *&#x2F;\n&#123;\n    while()\n    &#123;\n        思考;\n        P(fork[i]);\n        P(fork[i+1] mod 5);\n        吃通心面;\n        V(fork[i]);\n        V(fork[i+1] mod 5);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>总结</strong>：</p>\n<ul>\n<li>是否存在互斥变量（如果有多个人对同一个物体进行操作时，很显然需要判断是否有互斥）</li>\n<li>存在哪些主体（操作的哪些人）</li>\n<li>被操作物体的数量</li>\n</ul>\n<h2 id=\"资源分配问题-死锁\"><a href=\"#资源分配问题-死锁\" class=\"headerlink\" title=\"资源分配问题+死锁\"></a>资源分配问题+死锁</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>某系统有R1,R2,R3共三种资源，在T0时刻P1,P2,P3,P4这4个进程对资源的占用和需求情况如表所示，此时系统的可用资源向量为（2，1，2）。试问：<br>（1）将系统中各种资源总数和此刻各进程对各种资源的需求数量用向量或矩阵表示出来。<br>（2）如果此时P1,P2均发出资源请求向量request(1,0,1),为了保证系统的安全性，应该如何分配资源给这两个进程？说明你采用策略的原因。<br>（3）如果（2）中两个请求立即得到满足后，系统此刻是否处于死锁状态？</p></blockquote>\n<p><strong>解答</strong>:</p>\n<ol>\n<li>对于第一题，直接画个矩阵即可</li>\n<li>按需分配判断，查看剩下的系统资源是否可以满足某个进程的<strong>资源请求</strong>并<strong>释放</strong></li>\n<li>若同时分配给P1、P2进程资源(1,0,1)，则系统剩余资源(0,1,0) 此刻系统并<strong>没有立即进入死锁状态</strong>，因为这时所有进程<strong>没有提出新的资源申请</strong>，全部进程均没有因资源请求没得到满足而进入阻塞状态。只有当进程提出资源申请且全部进程都进入阻塞状态时，系统才处于死锁状态。</li>\n</ol>\n<h2 id=\"作业调度-计算时间相关\"><a href=\"#作业调度-计算时间相关\" class=\"headerlink\" title=\"作业调度+计算时间相关\"></a>作业调度+计算时间相关</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>多道程序系统中，供用户使用的内存空间有100KB，磁带机2台，打印机1台。系统采用可变式分区分配方式管理内存，对磁带机和打印机采用静态分配方式，并假设输入/输出操作的时间忽略不计。现有一作业序列如下：</p>\n<table>\n<thead>\n<tr>\n<th>作业号</th>\n<th>到达时间</th>\n<th>要求计算时间</th>\n<th>要求内存量</th>\n<th>申请磁带机数</th>\n<th>申请打印机数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>8：00</td>\n<td>25分</td>\n<td>15K</td>\n<td>1台</td>\n<td>1台</td>\n</tr>\n<tr>\n<td>2</td>\n<td>8：20</td>\n<td>10分</td>\n<td>30K</td>\n<td>—</td>\n<td>1台</td>\n</tr>\n<tr>\n<td>3</td>\n<td>8：20</td>\n<td>20分</td>\n<td>60K</td>\n<td>1台</td>\n<td>—</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8：30</td>\n<td>20分</td>\n<td>20K</td>\n<td>1台</td>\n<td>—</td>\n</tr>\n<tr>\n<td>5</td>\n<td>8：35</td>\n<td>15分</td>\n<td>10K</td>\n<td>1台</td>\n<td>1台</td>\n</tr>\n</tbody></table>\n<p>假设作业调度采用FCFS算法，优先分配内存的低地址区域且不准移动已在内存中的作业，在内存中的作业平分CPU时间，试问：<br>（1）    作业调度的次序是什么？<br>（2）    全部作业运行结束的时刻是什么？<br>（3）    写出所有作业的周转时间及最大的作业周转时间。<br>（4）    平均周转时间是多少？ </p></blockquote>\n<p><strong>解答</strong>:</p>\n<ul>\n<li><strong>明确</strong>：<strong>FCFS</strong>叫做”先来先服务“算法。作业在CPU中平分时间，意思就是分时间片，比如A,B在CPU内运行10分钟，相当于A运行了5分钟，B运行了5分钟。优先分配内存的<strong>低地址区域</strong>（这个与内存调度策略有关了）。</li>\n</ul>\n<h2 id=\"内存页调度问题-计算缺页率\"><a href=\"#内存页调度问题-计算缺页率\" class=\"headerlink\" title=\"内存页调度问题+计算缺页率\"></a>内存页调度问题+计算缺页率</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>已知页面走向为1，2，1，3，1，2，4，2，1，3，4，且开始执行时内存中没有页面。若只给该作业分配2个物理块，当采用FIFO页面淘汰算法时缺页率为多少？假定现有一种淘汰算法，该算法淘汰页面的策略为当需要淘汰页面时，就把刚使用过的页面作为淘汰对象，试问就相同的也面走向，其缺页率又为多少？</p></blockquote>\n<p><strong>解答</strong>:</p>\n<ul>\n<li><strong>明确</strong>：采用的哪种<strong>调度算法</strong>，<strong>物理块</strong>有多大</li>\n<li><strong>思路</strong>：绘制表格仔细填写即可</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>绘制页式转换图</p></blockquote>\n<img src=\"/post/操作系统期末复习/image-20220102100512566.png\" alt=\"image-20220102100512566\" style=\"zoom:80%;\" />\n\n<h2 id=\"根据页式or段页式求物理地址\"><a href=\"#根据页式or段页式求物理地址\" class=\"headerlink\" title=\"根据页式or段页式求物理地址\"></a>根据页式or段页式求物理地址</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在一个分段存储管理系统中，其段表如表1所示，试求出表2中逻辑地址对应的物理地址。</p>\n<p>表1</p>\n<table>\n<thead>\n<tr>\n<th>段号</th>\n<th>内存起始地址</th>\n<th>段长</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>210</td>\n<td>500</td>\n</tr>\n<tr>\n<td>1</td>\n<td>2350</td>\n<td>20</td>\n</tr>\n<tr>\n<td>2</td>\n<td>100</td>\n<td>90</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1350</td>\n<td>590</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1938</td>\n<td>95</td>\n</tr>\n</tbody></table>\n<p>表2</p>\n<table>\n<thead>\n<tr>\n<th>段号</th>\n<th>段内位移</th>\n<th>物理地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>430</td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>10</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>500</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>400</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>112</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>32</td>\n<td></td>\n</tr>\n</tbody></table></blockquote>\n<p><strong>解答</strong>:</p>\n<ul>\n<li><strong>明确</strong>：是否为<strong>非法地址</strong>，是否<strong>主存越界</strong></li>\n</ul>\n<h2 id=\"CPU利用率\"><a href=\"#CPU利用率\" class=\"headerlink\" title=\"CPU利用率\"></a>CPU利用率</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>设有两个处理机P1，P2，它们各有一个硬件高速缓冲存储器C1，C2，且各有一个主存储器M1，M2，其性能如表所示。假定两个处理机的指令系统相同，它们的指令执行时间与存储器的平均存取周期成正比。如果执行某个程序时，所需的指令或数据在缓冲区中存取到的概率P是0.7，试问这两个处理机速度哪个快？当P=0.9时，处理机的处理速度哪个快？</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>C1</th>\n<th>C2</th>\n<th>M1</th>\n<th>M2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储容量</td>\n<td>4KB</td>\n<td>4KB</td>\n<td>2MB</td>\n<td>2MB</td>\n</tr>\n<tr>\n<td>存取周期</td>\n<td>60ns</td>\n<td>80ns</td>\n<td>1us</td>\n<td>0.9us</td>\n</tr>\n</tbody></table></blockquote>\n<p><strong>解答</strong>：</p>\n<ul>\n<li><strong>明确</strong>：平均存取周期：<br>$$<br>T=T_CP+T_M(1-P)<br>$$<br>其中c与m分别是高速缓冲区，与主存区的存储周期。还有，根据题目意思得，取的指令或数据有两个来源，一个是<strong>高速缓冲区</strong>，一个是<strong>主存区</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>假设就绪队列中有10个进程，系统将时间片设为200ms,CPU进行进程切换要花费10 ms，试问系统开销所占的比率约为多少？</p></blockquote>\n<p><strong>解答</strong>：</p>\n<ul>\n<li>系统开销所占的比率=10/(10+200)=4.8%</li>\n</ul>\n","text":"题型我不知道 Chp1 绪论操作系统的特性：并发、共享、不确定新。 Chp2 操作系统的组织结构操作系统虚拟机什么是操作系统虚拟机？ 在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。 处理机的状态设置处理机状态的目...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"学习","slug":"学习","count":3,"path":"api/categories/学习.json"}],"tags":[{"name":"学习","slug":"学习","count":4,"path":"api/tags/学习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">题型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp1-%E7%BB%AA%E8%AE%BA\"><span class=\"toc-text\">Chp1 绪论</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Chp2 操作系统的组织结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">操作系统虚拟机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">处理机的状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">中断技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">向量中断</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp3-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">Chp3 用户界面</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">系统功能调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp4-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Chp4 并发处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">进程概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">进程控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">进程的相互制约关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">同步机构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程通信</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp5-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">Chp5 资源分配与调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">资源分配机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">资源分配策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp6-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">Chp6 处理机调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E5%A4%9A%E7%BA%A7%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">处理机的多级调度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">作业调度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">进程调度</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp7-%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">Chp7 主存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">分区存储管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">页式存储管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">页式地址变换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">淘汰策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">段页式存储管理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp8-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">Chp8 输入&#x2F;输出管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">缓冲技术</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D\"><span class=\"toc-text\">设备分配</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spooling%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">Spooling系统</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Chp9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">Chp9 文件系统</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E9%A2%98%E5%9E%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">基本计算题型分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#P-V%E4%BF%A1%E5%8F%B7%E7%81%AF\"><span class=\"toc-text\">P,V信号灯</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98-%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">资源分配问题+死锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6-%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">作业调度+计算时间相关</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E9%A1%B5%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98-%E8%AE%A1%E7%AE%97%E7%BC%BA%E9%A1%B5%E7%8E%87\"><span class=\"toc-text\">内存页调度问题+计算缺页率</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%8D%AE%E9%A1%B5%E5%BC%8For%E6%AE%B5%E9%A1%B5%E5%BC%8F%E6%B1%82%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">根据页式or段页式求物理地址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CPU%E5%88%A9%E7%94%A8%E7%8E%87\"><span class=\"toc-text\">CPU利用率</span></a></li></ol></li></ol>","author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"2021年度总结","uid":"10e799bf47669bd7fff35712248e1c6e","slug":"2021年度总结","date":"2021-12-31T12:34:06.000Z","updated":"2021-12-31T15:15:35.343Z","comments":true,"path":"api/articles/2021年度总结.json","keywords":null,"cover":"/post/2021年度总结/u=3715033498,2456029672&fm=253&fmt=auto&app=120&f=JPEG.webp","text":"引言这是我第一次写年度总结在自己的博客上面，用来总结这一年到底干了什么，以及需要改进的是什么。2021年对我来说是一个过渡期，可能是让我更加明确自己方向的一个时期，但是在这方面还是拥有一点疑虑，需要再深思熟虑。 2021年做了什么？其实大致的忘了自己2021年开始到底做了什么，因...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"年度总结","slug":"年度总结","count":1,"path":"api/categories/年度总结.json"}],"tags":[{"name":"总结","slug":"总结","count":1,"path":"api/tags/总结.json"}],"author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Unity3d关键词汇总","uid":"85bcb60ef3df802e81a5da2276802e9f","slug":"Unity3d关键词汇总","date":"2021-12-28T04:01:19.000Z","updated":"2021-12-29T15:02:02.242Z","comments":true,"path":"api/articles/Unity3d关键词汇总.json","keywords":null,"cover":"/post/Unity3d关键词汇总/m001.jpg","text":"根据类型获取某个对象 &#x2F;&#x2F;这里我们找的是Canvas这个对象，该函数只找到一个 Canvas canvas &#x3D; FindObjectOfType&lt;Canvas&gt;(); 获取预制体 &#x2F;&#x2F;获取预制体 &#x2F;&#x2F...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"Unity3d","slug":"Unity3d","count":1,"path":"api/categories/Unity3d.json"}],"tags":[{"name":"Unity3d","slug":"Unity3d","count":1,"path":"api/tags/Unity3d.json"},{"name":"学习","slug":"学习","count":4,"path":"api/tags/学习.json"}],"author":{"name":"懒懒瑭岚","slug":"blog-author","avatar":"/post/java期末复习/1761bac35e69253aa2999ff26b7ed6bbf63c8a8a.jpg@100Q.webp","link":"/","description":"平平无奇的博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}